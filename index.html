<!DOCTYPE html>

<head>
    <title>Easy RISC-V</title>

    <script type="module" src="easyriscv.js"></script>
    <link rel="stylesheet" href="style.css">
    <meta charset='utf-8'>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>

<body>

    <header class="page-banner">Easy RISC-V</header>

    <p>(Last updated: 2025-10-31 13:49)</p>

    <nav class="table-of-contents">
        <ul>
        <li><a href="#introduction"
        id="toc-introduction">Introduction</a></li>
        <li><a href="#my-first-risc-v-assembly-program"
        id="toc-my-first-risc-v-assembly-program">My first RISC-V
        assembly program</a></li>
        <li><a href="#emulator-controls"
        id="toc-emulator-controls">Emulator controls</a></li>
        <li><a href="#processor-state"
        id="toc-processor-state">Processor state</a></li>
        <li><a href="#instruction-syntax"
        id="toc-instruction-syntax">Instruction syntax</a></li>
        <li><a href="#computational-instructions"
        id="toc-computational-instructions">Computational
        instructions</a>
        <ul>
        <li><a href="#arithmetic-instructions"
        id="toc-arithmetic-instructions">Arithmetic
        instructions</a></li>
        <li><a href="#bitwise-instructions"
        id="toc-bitwise-instructions">Bitwise instructions</a></li>
        <li><a href="#comparison-instructions"
        id="toc-comparison-instructions">Comparison
        instructions</a></li>
        <li><a href="#shift-instructions"
        id="toc-shift-instructions">Shift instructions</a></li>
        <li><a href="#thats-it" id="toc-thats-it">That’s it…?</a></li>
        <li><a href="#summary-of-computational-instructions"
        id="toc-summary-of-computational-instructions">Summary of
        computational instructions</a></li>
        </ul></li>
        <li><a href="#intermission-larger-numbers"
        id="toc-intermission-larger-numbers">Intermission: Larger
        numbers</a></li>
        <li><a href="#jumps-and-branches"
        id="toc-jumps-and-branches">Jumps and branches</a>
        <ul>
        <li><a href="#branches" id="toc-branches">Branches</a></li>
        <li><a href="#jumps" id="toc-jumps">Jumps</a></li>
        <li><a href="#jump-and-link" id="toc-jump-and-link">Jump and
        link</a></li>
        </ul></li>
        <li><a href="#memory" id="toc-memory">Memory</a>
        <ul>
        <li><a href="#basic-memory-accesses"
        id="toc-basic-memory-accesses">Basic memory accesses</a></li>
        <li><a href="#smaller-widths" id="toc-smaller-widths">Smaller
        widths</a></li>
        <li><a href="#memory-mapped-io"
        id="toc-memory-mapped-io">Memory-mapped I/O</a></li>
        </ul></li>
        <li><a href="#functions" id="toc-functions">Functions</a>
        <ul>
        <li><a href="#register-aliases-and-calling-conventions"
        id="toc-register-aliases-and-calling-conventions">Register
        aliases and calling conventions</a></li>
        <li><a href="#the-stack" id="toc-the-stack">The stack</a></li>
        </ul></li>
        <li><a href="#intermission-numeric-labels"
        id="toc-intermission-numeric-labels">Intermission: Numeric
        labels</a></li>
        <li><a href="#position-independence"
        id="toc-position-independence">Position independence</a></li>
        <li><a href="#privileged-architecture-fundamentals"
        id="toc-privileged-architecture-fundamentals">Privileged
        architecture fundamentals</a>
        <ul>
        <li><a href="#privilege-levels"
        id="toc-privilege-levels">Privilege levels</a></li>
        <li><a href="#control-and-status-registers-csrs"
        id="toc-control-and-status-registers-csrs">Control and status
        registers (CSRs)</a></li>
        <li><a href="#counters" id="toc-counters">Counters</a></li>
        <li><a href="#current-privilege-level"
        id="toc-current-privilege-level">Current privilege
        level</a></li>
        </ul></li>
        <li><a href="#exceptions" id="toc-exceptions">Exceptions</a>
        <ul>
        <li><a href="#exception-entry"
        id="toc-exception-entry">Exception entry</a></li>
        <li><a href="#exception-causes"
        id="toc-exception-causes">Exception causes</a></li>
        <li><a href="#exception-return"
        id="toc-exception-return">Exception return</a></li>
        </ul></li>
        <li><a href="#handling-user-mode"
        id="toc-handling-user-mode">Handling User mode</a>
        <ul>
        <li><a href="#entering-user-mode"
        id="toc-entering-user-mode">Entering User mode</a></li>
        <li><a href="#intentionally-causing-an-exception"
        id="toc-intentionally-causing-an-exception">Intentionally
        causing an exception</a></li>
        <li><a href="#saving-and-restoring-all-registers"
        id="toc-saving-and-restoring-all-registers">Saving and restoring
        all registers</a></li>
        </ul></li>
        <li><a href="#writing-a-very-very-bare-bones-operating-system"
        id="toc-writing-a-very-very-bare-bones-operating-system">Writing
        a very very bare bones operating system</a>
        <ul>
        <li><a href="#design" id="toc-design">Design</a></li>
        <li><a href="#code" id="toc-code">Code</a></li>
        <li><a href="#pseudocode-reference"
        id="toc-pseudocode-reference">Pseudocode reference</a></li>
        </ul></li>
        <li><a href="#lies-and-omissions"
        id="toc-lies-and-omissions">Lies and omissions</a></li>
        <li><a href="#references"
        id="toc-references">References</a></li>
        <li><a href="#thanks" id="toc-thanks">Thanks</a></li>
        <li><a href="#license" id="toc-license">License</a></li>
        <li><a href="#index" id="toc-index">Index</a>
        <ul>
        <li><a href="#instructions"
        id="toc-instructions">Instructions</a></li>
        <li><a href="#registers-and-csrs"
        id="toc-registers-and-csrs">Registers and CSRs</a></li>
        <li><a href="#special-assembly-syntax"
        id="toc-special-assembly-syntax">Special assembly
        syntax</a></li>
        <li><a href="#other-terms" id="toc-other-terms">Other
        terms</a></li>
        </ul></li>
        </ul>
    </nav>

<!-- SPDX-License-Identifier: CC0-1.0 -->
<p><a href="?no-emulator">(Emulators disabled version)</a></p>
<div class="narrow-screen-warning">
<p>This page is not designed to be used on a narrow screen or without
CSS. If you’re having issues using the emulator, try the <a
href="?no-emulator">emulators disabled version</a>.</p>
</div>
<p>An interactive introduction to RISC-V assembly programming, by <a
href="https://github.com/dramforever">dramforever</a>.</p>
<p>Interested in the code? Want to report an issue? Check out the GitHub
page: <a href="https://github.com/dramforever/easyriscv"
class="uri">https://github.com/dramforever/easyriscv</a></p>
<h1 id="introduction"><a href="#introduction" class="anchor-link"
aria-hidden="true"></a>Introduction</h1>
<p>Inspired by <a href="https://skilldrick.github.io/easy6502/">Easy
6502 by Nick Morgan</a>, this is a quick-ish introductory tutorial to
RISC-V assembly programming. This tutorial is intended for those with a
basic familiarity with low level computer science concepts, but
unfamiliar with RISC-V. If you’re curious about RISC-V, I hope this will
be a good start to your journey to learning about it.</p>
<p>RISC-V (pronounced “risk-five”), as its name suggests, is <a
href="https://en.wikipedia.org/wiki/Reduced_instruction_set_computer">RISC
(Reduced instruction set computer)</a> architecture. Having started its
life at UC Berkerley, RISC-V has bred a lively community of students,
researchers, engineers and hobbyists working on software and hardware.
Some highlights of RISC-V include:</p>
<ul>
<li>Clean design: Although loosely based on many previous designs,
RISC-V is at its core a new and clean design. It does away with integer
status flags like “carry” or “overflow”, and does not have MIPS’s branch
delay slots. RISC-V is designed primarily as a target for compilers, but
writing RISC-V assembly by hand is still quite pleasant.</li>
<li>Open standard: RISC-V specifications are developed publicly and
anyone can use them without copyright or patent licensing issues. Many
researchers and companies around the world have made their own RISC-V
processor cores and chips based on these specificaions.</li>
<li>Community support: If you want to make your own processors, rather
than paying a hefty license fee to Arm, or designing your own
architecture, you can just use RISC-V. Using RISC-V instead of a custom
architecture allows you to make use of the existing and growing software
ecosystem instead of having to maintain your own.</li>
</ul>
<p>RISC-V is less mature than more established architectures like x86 or
Arm, but it is quickly gaining steam and has found great success in many
areas of application, such as embedded systems, custom processors,
education, and research.</p>
<p>This article will cover the 32-bit bare bones RV32I_Zicsr instruction
set with a tiny subset of the privileged architecture. You’ll probably
never find a “real” chip with such bare bones instruction support. Most
of them will have more <em>extensions</em> for other features like
floating point or compressed instructions. However, I would still
consider what we have here a “complete” instruction set. For example,
Rust has <a
href="https://doc.rust-lang.org/nightly/rustc/platform-support/riscv32-unknown-none-elf.html">Tier
2 support</a> for the target <code>riscv32i-unknown-none-elf</code>
which works completely fine with only the instructions we’ll cover
here.</p>
<p>Speaking of instructions we will cover, why don’t we meet the 45 of
them right here and now:</p>
<!-- TODO: Ordering? -->
<pre><code>lui auipc
jal jalr
beq bne blt bge bltu bgeu
lb lh lw lbu lhu sb sh sw
addi slti sltiu xori ori andi slli srli srai
add sub slt sltu xor or and sll srl sra
ecall ebreak
csrrw csrrs csrrc csrrwi csrrsi csrrci</code></pre>
<p>Some of these instruction names should ring a bell (<code>add</code>,
<code>or</code>, <code>xor</code>). Others will look like they have some
pattern to it. A few weird ones like <code>auipc</code> stand out. These
instructions form the foundation of RISC-V, performing the basic tasks a
processor would do.</p>
<p>You will also catch a glimpse of what creating an operating system on
RISC-V is like, namely handling exceptions and privilege levels.</p>
<p>Let’s get started.</p>
<h1 id="my-first-risc-v-assembly-program"><a
href="#my-first-risc-v-assembly-program" class="anchor-link"
aria-hidden="true"></a>My first RISC-V assembly program</h1>
<p>Throughout this article you will see emulator panes like these:</p>
<p>(If you just see a code block, there’s a JavaScript problem. Make
sure you’ve enabled JavaScript, probably…)</p>
<div class="emulator-disabled">
start:
    addi x10, x0, 0x123
    ebreak
</div>
<p>You can use the buttons to control each emulator. Go ahead and click
on ‘Start’. A register view should pop up showing the state of the
emulator. Now click on ‘Run’. You’ll notice that:</p>
<pre><code>a0 (x10) 0x00000000</code></pre>
<p>Changed into:</p>
<pre><code>a0 (x10) 0x00000123</code></pre>
<p>And the emulator stopped. Congratulations, you’ve run your first
RISC-V assembly program. First here, at least.</p>
<h1 id="emulator-controls"><a href="#emulator-controls"
class="anchor-link" aria-hidden="true"></a>Emulator controls</h1>
<p>‘Start’ assembles your code and, well, starts the emulator. If
there’s a problem with your code, it will tell you about it and the
emulator will not start.</p>
<p>When the emulator is started, you can see the current state of the
registers in the side pane. More controls also becomes available. ‘Run’
runs until the end or until you hit ‘Pause’. ‘Step’ runs a single
step.</p>
<p>If you hit ‘Step’, you’ll notice that the above program takes two
steps to run. You may have guessed correctly that the first step
corresponds to <code>addi</code>, and the second corresponds to
<code>ebreak</code>. The top of the register panel shows
<code>pc</code>, the current instruction address, and in parentheses the
current instruction.</p>
<p>‘Dump’ opens a new window containing some text. There are two
sections: the first is the symbol table, which tells you about the
labels in your code:</p>
<pre><code># Symbols
# 0x40000000 start</code></pre>
<p>The second section is an annotated version of your code:</p>
<pre><code>start:
{ 0x40000000: 12300513 } addi x10, x0, 0x123
{ 0x40000004: 00100073 } ebreak</code></pre>
<p>This tells you that the <code>addi</code> instruction encodes to hex
<code>12300513</code>, and starts at address hex <code>40000000</code>.
Similarly, <code>ebreak</code> encodes as <code>00100073</code> at
address hex <code>40000004</code>.</p>
<p>(Note: RISC-V instructions are <em>little-endian</em>, meaning that
the four bytes of <code>addi</code> are actually
<code>13 05 30 12</code>.)</p>
<p>We’ll talk in detail about all of <code>pc</code>, registers,
instructions, labels, and the two checkboxes later.</p>
<p>Now you may have also guessed that <code>addi x10, x0, 0x123</code>
means <code>x10 = x0 + 0x123</code>. As for <code>ebreak</code>, for
now, just remember that <code>ebreak</code> stops the emulator.</p>
<h1 id="processor-state"><a href="#processor-state" class="anchor-link"
aria-hidden="true"></a>Processor state</h1>
<p>The <span id="term-program-counter"><em>program counter</em></span>,
or <span id="term-pc"><em><code>pc</code></em></span> is the address of
the current instruction. It points to the instruction to be
executed.</p>
<p>RV32I has 31 <span id="term-general-purpose-registers"><em>general
purpose registers</em></span> numbered <span
id="reg-x1-through-x31"><em><code>x1</code> through
<code>x31</code></em></span>. These can contain any 32-bit data.</p>
<p>(If you’re wondering, there are no flags for RV32I.)</p>
<p>The register <span id="reg-x0"><em><code>x0</code></em></span> is a
special “zero register”. For computational instructions, you can use
<code>x0</code> anywhere a register is expected. Reading it always gives
zero, and writing to it just gets ignored. The use of a special register
simplifies the design of the architecture, and this design is shared by
MIPS and Arm AArch64. We will make good use of <code>x0</code> soon.</p>
<p>(Note: In the emulator, the instruction listed in parenthesis next to
<code>pc</code> in the register view is provided as a convenience and is
not part of the processor state.)</p>
<h1 id="instruction-syntax"><a href="#instruction-syntax"
class="anchor-link" aria-hidden="true"></a>Instruction syntax</h1>
<p>But before we can start talking about instructions themselves, we
need a way to talk about the <span
id="term-instruction-syntax"><em>instruction syntax</em></span> so I
can, you know, write it down for you.</p>
<p>The syntax of an instruction is the instruction name and then several
comma-separated operands. For example, for this instruction we’ve seen
above:</p>
<pre><code>addi x10, x0, 0x123</code></pre>
<p><code>x10</code> is the <span
id="term-destination-register"><em>destination register</em></span> or
<span id="term-rd"><em><code>rd</code></em></span>. The next operand is
the first (and only) <span id="term-source-register"><em>source
register</em></span> or <span
id="term-rs1"><em><code>rs1</code></em></span>. The last operand is an
<span id="term-immediate-value"><em>immediate value</em></span> or <span
id="term-imm"><em><code>imm</code></em></span>. Using these
abbreviations, we can summarize that the syntax for <code>addi</code>
is:</p>
<pre><code>addi rd, rs1, imm</code></pre>
<p>Some other instructions have a second source register or <span
id="term-rs2"><em><code>rs2</code></em></span>. For example, the
non-immediate <code>add</code> instruction has this syntax:</p>
<pre><code>add rd, rs1, rs2</code></pre>
<p>Some other instructions have no operands, like <code>ebreak</code>.
Others have slightly more complex operands.</p>
<h1 id="computational-instructions"><a
href="#computational-instructions" class="anchor-link"
aria-hidden="true"></a>Computational instructions</h1>
<p>Using the registers as a playground of numbers, we can use
computational instructions to work with them.</p>
<h2 id="arithmetic-instructions"><a href="#arithmetic-instructions"
class="anchor-link" aria-hidden="true"></a>Arithmetic instructions</h2>
<p>As we’ve seen above, you can get a RISC-V machine to add numbers
together.</p>
<p>The <span id="insn-addi"><em><code>addi</code></em></span>
instruction adds the value in <code>rs1</code> to the immediate value
<code>imm</code>, and puts the result in <code>rd</code>.</p>
<pre><code>addi rd, rs1, imm</code></pre>
<p>The <span id="insn-add"><em><code>add</code></em></span> instruction
adds the value in <code>rs1</code> to the value in <code>rs2</code>, and
puts the result in <code>rd</code>.</p>
<pre><code>add rd, rs1, rs2</code></pre>
<p>The opposite of addition is subtraction. The <span
id="insn-sub"><em><code>sub</code></em></span> instruction subtracts the
value in <code>rs2</code> from the value in <code>rs1</code>
(i.e. <code>rs1 - rs2</code>), and puts the result in <code>rd</code>.
There’s no corresponding <code>subi</code> instruction — Just use
<code>addi</code> with a negative number.</p>
<pre><code>sub rd, rs1, rs2</code></pre>
<p>Step through this demo program and try writing your own additions and
subtractions:</p>
<div class="emulator-disabled">
    addi x10, x0, 0x123
    addi x11, x0, 0x555

    addi x12, x10, 0x765
    add x13, x10, x11
    sub x14, x11, x10

    addi x10, x10, 1
    addi x10, x10, 1
    addi x10, x10, -1
    addi x10, x10, -1

    ebreak
</div>
<p>One thing you should note is that the immediate value has a limited
range, namely <code>[-2048, 2047]</code>, the range of a 12-bit two’s
complement signed integer. This limitation is because RV32I uses fixed
32-bit i.e. 4-byte instructions, and only the top 12 bits are available
to encode an immediate value. You can see the hexadecimal value encoded
in the instruction from the ‘Dump’. This article will not go into much
further detail about instruction encodings.</p>
<pre><code>{ 0x40000000: 12300513 } addi x10, x0, 0x123
{ 0x40000004: 55500593 } addi x11, x0, 0x555</code></pre>
<p>Even instructions as simple as addition and subtraction have other
interesting uses. We have already used <code>addi x10, x0, 0x123</code>
to put <code>0x123</code> in the register <code>x10</code>. When writing
in assembly, we can use a little shortcut called <span
id="term-pseudoinstructions"><em>pseudoinstructions</em></span>. The
<span id="insn-li"><em><code>li</code></em></span> (“load immediate”)
pseudoinstruction is a convenient way to put a small value in a
register. It expands to <code>addi rd, x0, imm</code> when
<code>imm</code> is in the range <code>[-2048, 2047]</code>.</p>
<pre><code>li rd, imm</code></pre>
<p>When <code>imm</code> is <code>0</code>, <code>addi</code> copies the
value without changing it because adding zero is the same as doing
nothing. The <span id="insn-mv"><em><code>mv</code></em></span> (“move”)
pseudoinstruction copies the value from <code>rs1</code> to
<code>rd</code>. It expands to <code>addi rd, rs1, 0</code>.</p>
<pre><code>mv rd, rs1</code></pre>
<p>Using the pseudoinstruction is exactly equivalent to using the “real”
instruction. You can see in the dump that the two are assembled exactly
the same way.</p>
<div class="emulator-disabled">
    addi x10, x0, 0x123
    li x10, 0x123

    addi x11, x10, 0
    mv x11, x10

    ebreak
</div>
<p>Subtracting from zero is negation. What’s the negative of
<code>0x123</code>?</p>
<div class="emulator-disabled">
    li x10, 0x123
    sub x11, x0, x10

    ebreak
</div>
<p>Hmm, we get <code>0xfffffedd</code>. That’s the 32-bit <span
id="term-two’s-complement"><em>two’s complement</em></span>
representation of <code>-291</code>, or <code>-0x123</code>. There’s
plenty of tutorials on this out there, so we’ll just note that whenever
something is “signed”, RISC-V uses two’s complement representation. The
benefit of this is that there are fewer instructions for separate signed
and unsigned instructions — both signed and unsigned numbers have the
same overflow wrap-around behavior.</p>
<p>Speaking of overflow wrap-around, what happens if we add something
too much and it overflows? We’ll use <code>add</code> to repeatedly
double <code>0x123</code> and see what happens:</p>
<div class="emulator-disabled">
    li x10, 0x123
    add x10, x10, x10
    add x10, x10, x10
    add x10, x10, x10
    add x10, x10, x10
    add x10, x10, x10
    add x10, x10, x10
    add x10, x10, x10
    add x10, x10, x10
    add x10, x10, x10
    add x10, x10, x10
    add x10, x10, x10
    add x10, x10, x10
    add x10, x10, x10
    add x10, x10, x10
    add x10, x10, x10
    add x10, x10, x10
    add x10, x10, x10
    add x10, x10, x10
    add x10, x10, x10
    add x10, x10, x10
    add x10, x10, x10
    add x10, x10, x10
    add x10, x10, x10
    add x10, x10, x10

    ebreak
</div>
<p>As <code>0x123</code> crawls up to the upper bits and eventually we
get to <code>0x9180_0000</code>, in the next iteration it turns into
<code>0x2300_0000</code>. There was an overflow! Doubling of
<code>0x9180_0000</code> gives <code>0x1_2300_0000</code>, but that
needs 33 bits in binary, so the highest bit can’t be put in the result.
Since RISC-V doesn’t have flag bits for carry or overflow, it’s simply
gone. The programmer is expected to deal with this.</p>
<h2 id="bitwise-instructions"><a href="#bitwise-instructions"
class="anchor-link" aria-hidden="true"></a>Bitwise instructions</h2>
<p>While we’re talking about bits, another thing we can do with bits is
performing bitwise logical operations on them.</p>
<p>The <span id="insn-and"><em><code>and</code></em></span> instruction
performs a bitwise-“and” between the bits of <code>rs1</code> and
<code>rs2</code> and puts the result in <code>rd</code>. The <span
id="insn-or"><em><code>or</code></em></span> and <span
id="insn-xor"><em><code>xor</code></em></span> instructions similarly
performs bitwise-“or” and bitwise-“xor”, respectively.</p>
<pre><code>and rd, rs1, rs2
or rd, rs1, rs2
xor rd, rs1, rs2</code></pre>
<p>Immediate operand versions of the three, namely <span
id="insn-andi"><em><code>andi</code></em></span>, <span
id="insn-ori"><em><code>ori</code></em></span>, <span
id="insn-xori"><em><code>xori</code></em></span> also exist.</p>
<pre><code>andi rd, rs1, imm
ori rd, rs1, imm
xori rd, rs1, imm</code></pre>
<p>Here are some random bit operation examples you can play with:</p>
<div class="emulator-disabled">
    li x10, 0x5a1
    xori x10, x10, 0xf0
    xori x10, x10, -1

    li x11, 0x5a1
    addi x12, x11, -1
    and x11, x11, x12
    addi x12, x11, -1
    and x11, x11, x12
    addi x12, x11, -1
    and x11, x11, x12

    li x13, 0x5a1
    ori x14, x13, 0xf
    ori x14, x13, 0xff
    ori x14, x13, 0xf0

    ebreak
</div>
<p>Remember that the immediate value is in the range
<code>[-2048, 2047]</code>. For negative values, the two’s complement
representation used means that the high bits are all ones. For example,
using <code>-1</code> as <code>imm</code> means the second operand is
binary all ones, or <code>0xffff_ffff</code>. This allows us to use
<code>xori rd, rs1, -1</code> as bitwise-“not”.</p>
<div class="emulator-disabled">
    li x10, 0x5a1
    xori x11, x10, -1

    or x12, x10, x11
    add x13, x10, x11

    ebreak
</div>
<p>Another interesting operation you can do is to round/<span
id="term-align"><em>align</em></span> something up or down to a multiple
of a power of two. For example, if you want to find the closest multiple
of 16 below <code>a</code>, in binary that would be clearing the lowest
4 bits, or <code>a &amp; ~0b1111</code>. Conveniently, that’s
<code>a &amp; -16</code> in two’s complement.</p>
<p>Aligning up is less intuitive, but one idea would be adding 16 first.
However that gives an incorrect result for multiples of 16. It’s easy
enough to fix though: adding one less works exactly right:
<code>(a + 15) &amp; -16</code></p>
<div class="emulator-disabled">
    li x10, 0x123
    andi x11, x10, -16

    addi x12, x10, 15
    andi x12, x12, -16
    ebreak
</div>
<h2 id="comparison-instructions"><a href="#comparison-instructions"
class="anchor-link" aria-hidden="true"></a>Comparison instructions</h2>
<p>Usually when you write a comparison of some sort like
<code>a == b</code> or <code>a &gt;= b</code>, it’s used as a condition
for some <code>if</code> or loop, but… those things are complicated!
We’ll get to it later.</p>
<p>Sometimes you just want a boolean value out of a comparison. The C
convention uses 1 for true and 0 for false, and since the world runs on
C now, that’s what RISC-V provides.</p>
<p>In C there are six comparison operators:</p>
<pre><code>== != &lt; &gt; &lt;= &gt;=</code></pre>
<p>The values being compared can also be both signed or both
unsigned.</p>
<p>How many comparison instructions do we have at our disposal? Let’s
see…</p>
<p>The <span id="insn-slt"><em><code>slt</code></em></span> (“set less
than”) instruction compares <code>rs1</code> and <code>rs2</code> as
signed 32-bit integers, and sets <code>rd</code> to <code>1</code> if
<code>rs1 &lt; rs2</code>, and <code>0</code> otherwise
(<code>rs1 &gt;= rs2</code>). The <span
id="insn-sltu"><em><code>sltu</code></em></span> instruction is similar
but it treats the operands as unsigned values. <span
id="insn-slti"><em><code>slti</code></em></span> and <span
id="insn-sltiu"><em><code>sltiu</code></em></span> are similar but the
second operand is an immediate value.</p>
<pre><code>slt rd, rs1, rs2
sltu rd, rs1, rs2
slti rd, rs1, imm
sltiu rd, rs1, imm</code></pre>
<p>(Obscure side note, for completeness: for <code>sltiu</code>, the
immediate operand still has the range <code>[-2048, 2047]</code> but it
performs an <em>unsigned</em> comparison between <code>rs1</code> and
(the two’s complement of) the immediate value. This allows for some
counterintuitive but convenient use cases. For example, interpreting
<code>rs1</code> as a signed value:</p>
<pre><code>                    # C pseudocode:
sltiu rd, rs1, 42   #   rd = (rs1 &gt;= 0) &amp;&amp; (rs1 &lt; 42)
sltiu rd, rs1, -1   #   rd = (rs1 != -1)</code></pre>
<p>You don’t need to fully understand this now. Even GCC as of October
of 2025 fails to perform the second optimization.)</p>
<p>That’s… one of the six comparisons settled. What about the others? As
it turns out, we can synthesize any of the other five, using up to two
instructions.</p>
<p>Making <code>&gt;</code> from <code>&lt;</code> is easy, as you can
just swap the operands. Using <code>xori</code> with <code>1</code> we
can invert the result of a comparison, giving as <code>&lt;=</code> and
<code>&gt;=</code>.</p>
<div class="emulator-disabled">
    li x10, 0x3
    li x11, 0x5

    slt x12, x10, x11   # x10 &lt; x11
    slt x13, x11, x10   # x10 &gt; x11

    xori x14, x12, 1    # x10 &gt;= x11  i.e.  !(x10 &lt; x11)
    xori x15, x13, 1    # x10 &lt;= x11  i.e.  !(x10 &gt; x11)

    ebreak
</div>
<p>That was signed comparison but unsigned comparison works the same
using <code>sltu</code> instead of <code>slt</code>.</p>
<p>As for <code>==</code> and <code>!=</code>, let’s tackle the easier
case of <code>a == 0</code> and <code>a != 0</code> first. We will use
the fact that for unsigned values, <code>a != 0</code> is equivalent to
<code>a &gt; 0</code>. The negation of that is <code>a &lt;= 0</code>,
which is the same as <code>a &lt; 1</code>.</p>
<div class="emulator-disabled">
    li x10, 0

    sltu x11, x0, x10   # 0 &lt;u x10  i.e.  x10 != 0
    sltiu x12, x10, 1   # x10 &lt;u 1  i.e.  x10 == 0

    ebreak
</div>
<p>As a bonus, this is also how we get logical not and converting
integer to boolean.</p>
<p>Now that we have these, <code>a == b</code> is just
<code>(a - b) == 0</code>, and <code>a != b</code> is just
<code>(a - b) != 0</code>.</p>
<div class="emulator-disabled">
    li x10, 0x3         # a
    li x11, 0x5         # b
    sub x10, x10, x11   # x10 = a - b

    sltu x11, x0, x10   # 0 &lt;u x10  i.e.  x10 != 0
    sltiu x12, x10, 1   # x10 &lt;u 1  i.e.  x10 == 0

    ebreak
</div>
<p>In summary: (<code>[u]</code> means use <code>u</code> for unsigned
comparison and nothing for signed comparison)</p>
<ul>
<li><code>a &lt; b</code>: <code>slt[u]</code></li>
<li><code>a &gt; b</code>: <code>slt[u] reversed</code></li>
<li><code>a &lt;= b</code>: <code>slt[u] reversed ; xori 1</code></li>
<li><code>a &gt;= b</code>: <code>slt[u] ; xori 1</code></li>
<li><code>a == 0</code>: <code>sltu x0</code></li>
<li><code>a != 0</code>: <code>sltiu 1</code></li>
<li><code>a == b</code>: <code>sub ; sltu x0</code></li>
<li><code>a != b</code>: <code>sub ; sltiu 1</code></li>
</ul>
<h2 id="shift-instructions"><a href="#shift-instructions"
class="anchor-link" aria-hidden="true"></a>Shift instructions</h2>
<p>There is no way I can do justice to the usage of bit shifts in the
middle of a tutorial on RISC-V assembly. If you’re here, you’ve probably
heard of them. There’s nothing really special to the way they appear in
usage for RISC-V.</p>
<p>There are two variants for right shifting: <span
id="insn-srl"><em><code>srl</code></em></span> and <span
id="insn-srli"><em><code>srli</code></em></span> (“shift right logical
(immediate)”) performs “logical” or unsigned right shift where the
leftmost or most significant bits are filled with zeros.</p>
<p><span id="insn-sra"><em><code>sra</code></em></span> and <span
id="insn-srai"><em><code>srai</code></em></span> (“shift right
arithmetic (immediate)”) performs “arithmetic” or signed right shift
where the leftmost bits are filled with the same of what highest/sign
bit was. So if you shift a negative value, you get a negative result; if
you shift a non-negative value, you get a non-negative result.</p>
<pre><code>srl rd, rs1, rs2
sra rd, rs1, rs2
srli rd, rs1, imm
srai rd, rs1, imm</code></pre>
<p>As before, the ones with the <code>i</code> suffix take an immediate
value as the second operand, and the ones without <code>i</code> take a
register.</p>
<div class="emulator-disabled">
    li x10, -3
    srai x11, x10, 16
    srli x12, x10, 16
    ebreak
</div>
<p>So <code>a</code> means “arithmetic”, <code>l</code> means “logical”.
Got it.</p>
<p>Left shifts have no such distinction. For consistency they are still
“logical”: <span id="insn-sll"><em><code>sll</code></em></span> is left
shift, and <span id="insn-slli"><em><code>slli</code></em></span> is
left shift with immediate.</p>
<pre><code>sll rd, rs1, rs2
slli rd, rs1, imm</code></pre>
<p>Aha, now we can blow up <code>0x123</code> without repeating
ourselves so much:</p>
<div class="emulator-disabled">
    li x10, 0x123
    slli x10, x10, 10
    slli x10, x10, 10
    slli x10, x10, 10
    ebreak
</div>
<p>The immediate value for shift instructions are special: they can only
be in the range of 0 to 31, inclusive, because it doesn’t make sense to
shift by a negative amount, or by more than 31. When the shift amount is
taken from a register, the value is considered modulo 32, or in other
words only the last 5 bits are taken into account:</p>
<div class="emulator-disabled">
    li x10, 0x444
    li x11, 0x81

    srl x10, x10, x11   # Same as shifting by 1

    ebreak
</div>
<p>For some fun, let’s try multiplying a value by 10, something you
would do when parsing decimal numbers: <code>a * 10</code> can be
rewritten as <code>(a &lt;&lt; 1) + (a &lt;&lt; 3)</code>:</p>
<div class="emulator-disabled">
    li x10, 0x5

    slli x11, x10, 1
    slli x12, x10, 3
    add x11, x11, x12

    ebreak
</div>
<h2 id="thats-it"><a href="#thats-it" class="anchor-link"
aria-hidden="true"></a>That’s it…?</h2>
<p>That’s it?</p>
<p>You may have noticed some glaring omissions. What we’ve learned
doesn’t even cover grade school math: multiplication and division are
missing.</p>
<p>RISC-V is designed with <span
id="term-extensions"><em>extensions</em></span> in mind. Remember that
as said in the introduction, RV32I is the barest bones of the barest
bones we’ve got. Forcing everyone to make their processors with
multiplication and division even for tasks that don’t need them would
waste silicon area and money on every chip. Instead those making RISC-V
processors have great freedom to choose, and indeed some would say they
have too much freedom.</p>
<p>For us… Honestly, I’m just glad we’ve been dealt a hand that we can
tackle completely in full. There’s no way I’m finishing writing this
tutorial if RV32I wasn’t so bare boned.</p>
<h2 id="summary-of-computational-instructions"><a
href="#summary-of-computational-instructions" class="anchor-link"
aria-hidden="true"></a>Summary of computational instructions</h2>
<p>(Operand <code>a</code> is <code>rs1</code>, and <code>b</code> is
<code>rs2</code> or immediate. In the instruction name <code>[i]</code>
means an immediate variant is available. Subscript <code>u</code> means
unsigned and <code>s</code> means two’s complement signed.)</p>
<table>
<colgroup>
<col style="width: 30%" />
<col style="width: 40%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr>
<th>Instruction</th>
<th>Operation</th>
<th>Immediate range</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>add[i]</code></td>
<td><code>a + b</code></td>
<td><code>[-2048, 2047]</code></td>
</tr>
<tr>
<td><code>sub</code></td>
<td><code>a - b</code></td>
<td>(n/a)</td>
</tr>
<tr>
<td><code>slt[i]</code></td>
<td><code>(a &lt;<sub>s</sub> b) ? 1 : 0</code></td>
<td><code>[-2048, 2047]</code></td>
</tr>
<tr>
<td><code>slt[i]u</code></td>
<td><code>(a &lt;<sub>u</sub> b) ? 1 : 0</code></td>
<td><code>[-2048, 2047]</code></td>
</tr>
<tr>
<td><code>xor[i]</code></td>
<td><code>a ^ b</code></td>
<td><code>[-2048, 2047]</code></td>
</tr>
<tr>
<td><code>or[i]</code></td>
<td><code>a | b</code></td>
<td><code>[-2048, 2047]</code></td>
</tr>
<tr>
<td><code>and[i]</code></td>
<td><code>a &amp; b</code></td>
<td><code>[-2048, 2047]</code></td>
</tr>
<tr>
<td><code>sll[i]</code></td>
<td><code>a &lt;&lt; b</code></td>
<td><code>[0, 31]</code></td>
</tr>
<tr>
<td><code>srl[i]</code></td>
<td><code>a &gt;&gt;<sub>u</sub> b</code></td>
<td><code>[0, 31]</code></td>
</tr>
<tr>
<td><code>sra[i]</code></td>
<td><code>a &gt;&gt;<sub>s</sub> b</code></td>
<td><code>[0, 31]</code></td>
</tr>
</tbody>
</table>
<h1 id="intermission-larger-numbers"><a
href="#intermission-larger-numbers" class="anchor-link"
aria-hidden="true"></a>Intermission: Larger numbers</h1>
<p>The <code>addi</code> instruction has limit on the immediate value.
How do we make bigger values?</p>
<p>The <span id="insn-lui"><em><code>lui</code></em></span> (“load upper
immediate”) instruction takes an immediate in the range
<code>[0, 1048575]</code> (i.e. up to <code>2<sup>20</sup> - 1</code>)
and sets <code>rd</code> to that value left shifted 12 bits:</p>
<pre><code>lui rd, imm20</code></pre>
<p>That was… slightly confusing. Why don’t we give it a try:</p>
<div class="emulator-disabled">
    lui x10, 1
    lui x11, 2
    ebreak
</div>
<p>Instead of <code>li</code> loading a “low” immediate, we control the
<em>upper</em> 20 bits of what we put in the register. After that, we
can use another <code>addi</code> instruction to fill in the lower bits.
For example, if we want <code>0x12345</code>:</p>
<div class="emulator-disabled">
    lui x10, 0x12
    addi x10, x10, 0x345
    ebreak
</div>
<p>For convenience, in assembly you can use <span
id="rel-%hi()"><em><code>%hi()</code></em></span> and <span
id="rel-%lo()"><em><code>%lo()</code></em></span> to extract the, well,
high 20 and low 12 bits of a value. The previous example could also be
written:</p>
<div class="emulator-disabled">
    lui x10, %hi(0x12345)
    addi x10, x10, %lo(0x12345)
    ebreak
</div>
<p>Letting <code>lui</code> handle the high 20 bits, and
<code>addi</code> for the low 12 bits, you can make any 32-bit
value.</p>
<p>(A small complication arises if you want to use values with bit 11
set. In that case, the immediate operand to <code>addi</code> will have
to be negative. However <code>%hi</code> understands this and adds one
to compensate, so this <code>%hi</code>/<code>%lo</code> combination
does work for everything.)</p>
<h1 id="jumps-and-branches"><a href="#jumps-and-branches"
class="anchor-link" aria-hidden="true"></a>Jumps and branches</h1>
<p>So far, everything that we’ve had so far can be done on even the most
basic programmer’s calculator. To truly make a computer… do computer
stuff, we’d want loops and conditionals.</p>
<p>In RISC-V parlance, a <span id="term-branch"><em>branch</em></span>
is a conditional transfer of control flow, and a <span
id="term-jump"><em>jump</em></span> is an unconditional transfer of
control flow.</p>
<p>I think the branch instructions are slightly simpler, so let’s start
with those.</p>
<h2 id="branches"><a href="#branches" class="anchor-link"
aria-hidden="true"></a>Branches</h2>
<p>All the branch instruction follow the form “If some comparison, go to
somewhere.” The conditions are:</p>
<ul>
<li><span id="insn-beq"><em><code>beq</code></em></span>:
<code>rs1 == rs2</code> (“equal”)</li>
<li><span id="insn-bne"><em><code>bne</code></em></span>:
<code>rs1 != rs2</code> (“not equal”)</li>
<li><span id="insn-blt"><em><code>blt</code></em></span>:
<code>rs1 &lt; rs2</code> signed (“less than”)</li>
<li><span id="insn-bge"><em><code>bge</code></em></span>:
<code>rs1 &gt;= rs2</code> signed (“greater or equal”)</li>
<li><span id="insn-bltu"><em><code>bltu</code></em></span>:
<code>rs1 &lt; rs2</code> unsigned (“less than unsigned”)</li>
<li><span id="insn-bgeu"><em><code>bgeu</code></em></span>:
<code>rs1 &gt;= rs2</code> unsigned (“greater or equal unsigned”)</li>
</ul>
<p>(In case you’re wondering about the confusing choice of ordering
operators here, it’s just that the negation of <code>&lt;</code> is
<code>&gt;=</code>.)</p>
<pre><code>beq rs1, rs2, label
bne rs1, rs2, label
blt rs1, rs2, label
bge rs1, rs2, label
bltu rs1, rs2, label
bgeu rs1, rs2, label</code></pre>
<p>Oh, right, almost forgot to explain what labels are. Labels are
convenience identifiers for addresses at some line of your code. They
are some identifier followed by a colon (like <code>this:</code>). They
can appear on a line of its own, or before any instruction on the line.
You can see which address they point to using the “Dump” button. The
third operand of a branch instruction is a label to jump to if the
condition holds.</p>
<p>Let’s add up all the numbers from 1 to 100:</p>
<div class="emulator-disabled">
    li x10, 100         # i = 100
    li x11, 0           # sum = 0

loop:
    add x11, x11, x10   # sum = sum + i
    addi x10, x10, -1   # i = i - 1
    blt x0, x10, loop   # If i &gt; 0: loop again
                        # Otherwise: done

    ebreak
</div>
<p>You can try your hands on making your favorite loops, like fibonacci
numbers or something. Speaking of trying your hands, just so we’re
ready, here’s what an infinite loop looks like. Try pausing or stopping
the loop, and single stepping through the instructions.</p>
<div class="emulator-disabled">
loop:
    addi x10, x10, 1
    add x11, x11, x10
    beq x0, x0, loop
</div>
<p>(If you know a thing or two about JavaScript in the browser, you’ll
know that a real infinite loop in JavaScript makes the whole page
becomes unresponsive, unless it’s in a worker or something. The “Run”
button here just runs the emulator for a certain number of steps,
pausing by giving back control to the event loop in between.)</p>
<p>(This isn’t the preferred way to write an unconditional jump. We’ll
see what is later.)</p>
<p>By the way, there’s no <code>bgt[u]</code> or <code>ble[u]</code>
because you can just swap <code>rs1</code> and <code>rs2</code> to get
those.</p>
<h2 id="jumps"><a href="#jumps" class="anchor-link"
aria-hidden="true"></a>Jumps</h2>
<p>There are two jump instructions in RISC-V. One of them is <span
id="insn-jal"><em><code>jal</code></em></span> “jump and link”, which
sets <code>rd</code> to the address of the following instruction, and
then jumps to a label:</p>
<pre><code>jal rd, label</code></pre>
<p>Another is <span id="insn-jalr"><em><code>jalr</code></em></span>
“jump and link register”, which sets <code>rd</code> to the address of
the following instruction, and then jumps to the address at
<code>imm + rs1</code>.</p>
<pre><code>jalr rd, imm(rs1)</code></pre>
<p>(Actually, the address jumped to is
<code>(imm + rs1) &amp; ~1</code>, i.e. the least significant bit is
cleared. This distinction won’t come up in normal code, like, pretty
much ever.)</p>
<p>Eesh, that’s some funky looking syntax. When you see parentheses like
this, it has something to do with an <em>address</em>. Parens means
address.</p>
<p>That’s… still a lot going on. Let’s take on some simpler cases first:
If <code>rd</code> is <code>x0</code> then the only thing these
instructions do is jumping. We can use it instead of the branch
instructions for an unconditional jump.</p>
<div class="emulator-disabled">
loop:
    # Yes this is an infinite loop.
    # You can see that we execute
    # this one instruction over and over
    jal x0, loop
</div>
<p>For convenience, a pseudoinstruction is available for you: <span
id="insn-j"><em><code>j</code></em></span> (“jump”) is for
<code>jal</code> with <code>rd</code> being <code>x0</code>:</p>
<pre><code>j label</code></pre>
<p>As for why you would want to do this… Well, we only have 32 bits per
instruction, and since the <code>jal</code> instruction only needs one
register number instead of the branch instructions’ two, and it doesn’t
need a condition, the instruction encoding permits jumping over a longer
range. So this is always preferred over something like
<code>beq x0, x0, label</code> for a jump.</p>
<p>As for <code>jalr</code>, you can jump to an address that’s stored in
a register. In C, that would be dealing with function pointers. You’d
need this any time dynamic dispatch is needed. For example, we load the
address of <code>foo</code> into a register first before jumping to
it.</p>
<div class="emulator-disabled">
    lui x10, %hi(foo)
    addi x10, x10, %lo(foo)
    jalr x0, 0(x10)

    # This isn't executed
    li x12, 1
    ebreak

foo:
    # This is executed
    li x12, 2
    ebreak
</div>
<p>In case you forgot by now, the <code>lui</code>/<code>addi</code>
combo at the start puts the address of the label <code>foo</code> in
register <code>x10</code>.</p>
<p>Similar to <code>j</code>, <span
id="insn-jr"><em><code>jr</code></em></span> (“jump register”) is a
psuedoinstruction for <code>jalr</code> with <code>rd</code> being
<code>x0</code> and <code>imm</code> being <code>0</code>:</p>
<pre><code>jr rs1</code></pre>
<p>Hmmm… If I didn’t really need the address in <code>x10</code>, that
<code>addi</code> would be unnecessary, since <code>jalr</code> has the
ability to add a low immediate on its own:</p>
<div class="emulator-disabled">
    lui x10, %hi(foo)
    jalr x0, %lo(foo)(x10)

    # This isn't executed
    li x12, 1
    ebreak

foo:
    # This is executed
    li x12, 2
    ebreak
</div>
<p>What’s the advantage of this over <code>jal x0</code>? Since
<code>%hi</code> and <code>%lo</code> can represent any 32-bit value,
this two-instruction combo can jump to any address, free from range
restrictions. You do need a free scratch register for the high part of
the address though, but since RISC-V gives you 31 of them, this
shouldn’t be too much of a problem.</p>
<h2 id="jump-and-link"><a href="#jump-and-link" class="anchor-link"
aria-hidden="true"></a>Jump and link</h2>
<p>What’s the deal with the destination register then? What do you need
the address of the next instruction for? For jumping <em>back</em> of
course. We can use this functionality to call functions and return
back.</p>
<div class="emulator-disabled">
    li x10, 1
    jal x1, double  # Call double
    jal x1, double  # Call double
    ebreak

    # Double the value in x10
double:
    add x10, x10, x10
    jr x1           # Return
</div>
<p>Note that I used the register <code>x1</code> for this, which is the
register for providing the return address by convention. For
convenience, if the destination register is omitted in <code>jal</code>,
it defaults to <code>x1</code>. Meanwhile, <span
id="insn-ret"><em><code>ret</code></em></span> (“return”) is a
pseudoinstruction that stands for <code>jr x1</code>,
i.e. <code>jalr x0, 0(x1)</code>:</p>
<pre><code>jal label
ret</code></pre>
<p>So the example above can be rewritten more conveniently as:</p>
<div class="emulator-disabled">
    li x10, 1
    jal foo
    jal foo
    ebreak

foo:
    add x10, x10, x10
    ret
</div>
<h1 id="memory"><a href="#memory" class="anchor-link"
aria-hidden="true"></a>Memory</h1>
<p>That’s a nice computer we have here. Now we have… all of 31 × 4 = 124
bytes of storage in the form of registers to work with. I want more…</p>
<h2 id="basic-memory-accesses"><a href="#basic-memory-accesses"
class="anchor-link" aria-hidden="true"></a>Basic memory accesses</h2>
<p>The emulator has 1 MiB of memory starting at address
<code>0x4000_0000</code>. That’s <code>0x4000_0000</code> to
<code>0x400f_ffff</code>, inclusive. The assembler starts assembling at
the beginning of memory, as you can see in the dump, starting at address
<code>0x4000_0000</code>.</p>
<p>The <span id="dir-.word"><em><code>.word</code></em></span> <span
id="term-directive"><em>directive</em></span> straight up puts a
4-byte/32-bit word into the current position. You can specify multiple
values separated by commas.</p>
<pre><code>.word value [ , value [ , ...  ] ]</code></pre>
<p>The <span id="insn-lw"><em><code>lw</code></em></span> (“load word”)
instruction loads a word from the address <code>rs1 + imm</code> and
puts it in <code>rd</code>, in other words it reads the word from
memory:</p>
<pre><code>lw rd, imm(rs1)</code></pre>
<p>As with <code>jalr</code>, you can combine it with <code>lui</code>
to access any address.</p>
<div class="emulator-disabled">
    lui x10, %hi(foo)
    lw x11, %lo(foo)(x10)
    ebreak

foo:
    # Get it? foo, f00 ...
    .word 0xf00
</div>
<p>The <span id="insn-sw"><em><code>sw</code></em></span> (“store word”)
instruction stores <code>rs2</code> to a word in memory at address
<code>rs1 + imm</code>, in other words it writes the word to memory:</p>
<pre><code>sw rs2, imm(rs1)</code></pre>
<div class="emulator-disabled">
    lui x10, %hi(foo)
    lw x11, %lo(foo)(x10)

    li x12, 0x123
    sw x12, %lo(foo)(x10)

    # Now it's changed
    lw x13, %lo(foo)(x10)
    ebreak

foo:
    .word 0xf00
</div>
<p>Just to make absolutely sure we’re clear on this, <span
id="term-load"><em>load</em></span> means reading from memory, <span
id="term-store"><em>store</em></span> means writing to memory. Both
words can be nouns and verbs. Also, a <span
id="term-word"><em>word</em></span> is 32-bit for RISC-V.</p>
<p>Let’s have some fun. Can we have the program read itself?</p>
<div class="emulator-disabled">
here:
    lui x10, %hi(here)
    lw x10, %lo(here)(x10)
    ebreak
</div>
<p>Ohh that’s fun. Does this mean I can also write programs with just
<code>.word</code>?</p>
<div class="emulator-disabled">
    .word 0x40000537 # lui x10, %hi(here)
    .word 0x00052503 # lw x10, %lo(here)(x10)
    .word 0x00100073 # ebreak
</div>
<p>Oh that’s nice. Just a peek into the world of machine code and
instruction encodings… which we will not be getting into.</p>
<p>With memory accesses under our belt, we can address a lot more data
easily. Here’s an example where we find the sum of all the values in an
array. Note how we can access different addresses of memory, whereas
there is no way to address a register by a number in another
register.</p>
<div class="emulator-disabled">
    lui x10, %hi(array)
    addi x10, x10, %lo(array)

    li x11, 8   # length

    # Get end address
    slli x11, x11, 2
    add x11, x11, x10

    li x12, 0 # sum

loop:
    # If current == end, done
    beq x10, x11, end
    lw x13, 0(x10)      # Load from array
    add x12, x12, x13   # Add to sum
    addi x10, x10, 4    # Bump current pointer
    j loop

end:
    ebreak


array:
    .word 13, 24, 6, 7, 8, 19, 0, 4
</div>
<p>The equivalent in C would be something like</p>
<pre><code>uint32_t array[], length;

uint32_t *current = array;
uint32_t *end = array + length;
uint32_t sum = 0;

for (; current != end; current ++) {
    sum += *current;
}</code></pre>
<p>Note how adding one to a pointer to word bumps the address by 4,
because the addresses are all byte addresses, and one word is four
bytes. In C, the compiler handles the multiplier for you, but in
assembly you have to remember to do it manually.</p>
<!-- TODO: I need some memory dump thing to make useful examples of `sw` -->
<h2 id="smaller-widths"><a href="#smaller-widths" class="anchor-link"
aria-hidden="true"></a>Smaller widths</h2>
<p>Not everything in memory is word sized. You’ve already seen an array,
which is multiple-word-sized. There are also stuff smaller than
word-sized.</p>
<p>An obvious one is the <span id="term-byte"><em>byte</em></span>,
which is, well, 1-byte/8-bit and written <code>[u]int8_t</code> in C. In
the middle is the <span id="term-halfword"><em>halfword</em></span>,
which is 2-byte/16-bit and written <code>[u]int16_t</code> in C. You can
use the directives <span
id="dir-.byte"><em><code>.byte</code></em></span> and <span
id="dir-.half"><em><code>.half</code></em></span> respectively for those
data types.</p>
<pre><code>.byte value [ , value [ , ...  ] ]
.half value [ , value [ , ...  ] ]</code></pre>
<p>And just in case you don’t remember those, <span
id="dir-.2byte"><em><code>.2byte</code></em></span> means the same as
<code>.half</code>, and <span
id="dir-.4byte"><em><code>.4byte</code></em></span> means the same as
<code>.word</code>.</p>
<pre><code>.2byte value [ , value [ , ...  ] ] # Same as .half
.4byte value [ , value [ , ...  ] ] # Same as .word</code></pre>
<p>There’s a small problem with loading smaller-than-word sized values
into word-sized registers: What do you do with the rest of the bits?
Obviously the lowest of the bits gets the actual value loaded. There are
two most useful ways to fill the upper bits:</p>
<ul>
<li><span id="term-zero-extension"><em>zero extension</em></span>: The
higher bits are filled with zeros</li>
<li><span id="term-sign-extension"><em>sign extension</em></span>: The
higher bits are filled with copies of the highest bit of the original
value</li>
</ul>
<p>Zero extension is easy enough. As the name suggests, sign extension
has something to do with signed values. It’s what happens when you
convert a narrower signed value into a wider one.</p>
<p>(Keeping the rest of the bits unchanged isn’t a good option. It
complicates the implementation for processor, especially of modern high
performance design, to just write parts of a register. It would be
easiest if the new value didn’t depend on the old value.)</p>
<p>For example, the signed byte value <code>-100</code> is
<code>0x9c</code>. Since the highest bit i.e. the sign bit of it is
<code>1</code>, when we expand it into 32 bits we fill the high 24 bits
with one so the new value, <code>0xffff_ff9c</code> still represents
<code>-100</code>. This is sign extension.</p>
<p>If we want to convert the unsigned byte value <code>156</code>, still
<code>0x9c</code>, into an unsigned word, it would have to be
<code>0x0000_009c</code> to preserve its value.</p>
<p>For bytes, the <span id="insn-lb"><em><code>lb</code></em></span>
(“load byte”) instruction loads a byte and sign extends the result, and
the <span id="insn-lbu"><em><code>lbu</code></em></span> (“load byte
unsigned”) instruction does the same but zero extends the result. As
with <code>lw</code>, the address is <code>rs1 + imm</code>.</p>
<pre><code>lb rd, imm(rs1)
lbu rd, imm(rs1)</code></pre>
<p>Similarly for <span id="insn-lh"><em><code>lh</code></em></span>
(“load half”) and <span id="insn-lhu"><em><code>lhu</code></em></span>
(“load half unsigned”), just for unsigned halfwords (two bytes each,
remember):</p>
<pre><code>lh rd, imm(rs1)
lhu rd, imm(rs1)</code></pre>
<p>We can try out the sign extension and zero extension example from
earlier.</p>
<div class="emulator-disabled">
    # Signed
    li x10, -100
    lui x11, %hi(test)
    lb x11, %lo(test)(x11)

    # Unsigned
    li x12, 156
    lui x13, %hi(test)
    lbu x13, %lo(test)(x13)

    ebreak

test:
    .byte 0x9c
</div>
<p>Correspondingly, the <span
id="insn-sb"><em><code>sb</code></em></span> (“store byte”) and <span
id="insn-sh"><em><code>sh</code></em></span> (“store half”) do the
opposite of <code>lb</code> and <code>lh</code>, storing bytes and
halfwords to memory. Instead of widening small values to register size,
these take the lowest order bits from <code>rs1</code> and stores it to
memory. (There’s no <code>sbu</code> and <code>shu</code> because stores
are narrowing instead of widening operations.)</p>
<pre><code>sb rs2, imm(rs1)
sh rs2, imm(rs1)</code></pre>
<p>While we’re at it, here’s two more minor details. Firstly, <span
id="term-endianness"><em>endianness</em></span>. While theoretically big
endian RISC-V machines can exist, I’ve never seen one… and this emulator
is little endian, meaning that the four bytes in a word are laid out in
memory lowest first. So, <code>.byte 0x1, 0x2, 0x3, 0x4</code> would be
the same as <code>.word 0x04030201</code>.</p>
<div class="emulator-disabled">
    lui x10, %hi(test)
    lw x10, %lo(test)(x10)
    ebreak

test:
    .byte 0x1, 0x2, 0x3, 0x4
</div>
<p>Secondly, memory accesses should be <span
id="term-aligned"><em>aligned</em></span> for maximum efficiency. This
means that the address for a halfword/2byte should be a multiple of two,
and the address for a word/4byte should be a multiple of four.
Misaligned accesses (meaning, well, when the address is not aligned) may
not work as expected.</p>
<p>For user programs running on a rich operating systems, misaligned
accesses are supported but may be slow. In embedded application running
on microcontrollers and such, it might not work at all.</p>
<p>This emulator supports misaligned memory accesses.</p>
<div class="emulator-disabled">
    lui x10, %hi(test)
    addi x10, x10, %lo(test)

    lw x11, 0(x10)
    lw x12, 1(x10)
    lw x13, 3(x10)

    ebreak

test:
    .byte 1, 2, 3, 4, 5, 6, 7, 8
</div>
<p>Now you can try translating some basic C code into RISC-V assembly.
Functions are… still out of the question for now. Variables have to be
either global or put in registers. What else are we missing…</p>
<h2 id="memory-mapped-io"><a href="#memory-mapped-io"
class="anchor-link" aria-hidden="true"></a>Memory-mapped I/O</h2>
<p>Is it Hello World time? I think it’s Hello World time…</p>
<p>For a computer to not just be a space heater, we need some way for it
to at least generate output and take input. While other architectures
may have dedicated I/O instructions, RISC-V uses <span
id="term-memory-mapped-i/o"><em>memory mapped I/O</em></span>.
Essentially, this means that loads and stores to special addresses
communicate with other <span id="term-devices"><em>devices</em></span>.
They do not work like normal memory, and you should only use the
supported widths to access them.</p>
<p>One output device we have here is at address
<code>0x1000_0000</code>. Any 32-bit writes to it appends the lowest 8
bits as a byte to the text in the output pane. In other words, a
<code>sw</code> to that address writes a byte of output.</p>
<p>(The output pane uses UTF-8 encoding.)</p>
<!-- TODO: Uhh... Make the assembler support character and string literals? -->
<div class="emulator-disabled">
    lui x11, %hi(0x10000000)
    li x10, 0x48 # 'H'
    sw x10, 0(x11)
    li x10, 0x69 # 'i'
    sw x10, 0(x11)
    li x10, 0x21 # '!'
    sw x10, 0(x11)
    li x10, 0x0a # '\n'
    sw x10, 0(x11)
    ebreak
</div>
<p>Eh, close enough to greeting the entire world. We could refactor it a
bit to use a loop, or whatever… Now that we think about it, how about
going one step further and organize our code into some functions?</p>
<h1 id="functions"><a href="#functions" class="anchor-link"
aria-hidden="true"></a>Functions</h1>
<p>We already know how to call a function and return back. Namely,
<code>jal</code> calls a function, and <code>ret</code> returns. Usually
functions take arguments, use local variables, and return results. Since
there’s no real difference between the 31 general purpose registers, on
account of them being, well, general purpose, we could just use any of
them as we wish. Usually though, there are some standard conventions to
follow</p>
<h2 id="register-aliases-and-calling-conventions"><a
href="#register-aliases-and-calling-conventions" class="anchor-link"
aria-hidden="true"></a>Register aliases and calling conventions</h2>
<p>This whole time you probably have noticed that registers are listed
with two names each, and indeed both work identically in assembly.</p>
<div class="emulator-disabled">
    li x10, 1
    li a0, 1
    ebreak
</div>
<p>These <span id="term-register-aliases"><em>register
aliases</em></span> are named after their uses:</p>
<ul>
<li><span id="regalias-s0-through-s11"><em><code>s0</code> through
<code>s11</code></em></span> are <em>saved</em> registers</li>
<li><span id="regalias-t0-through-t6"><em><code>t0</code> through
<code>t6</code></em></span> are <em>temporary</em> registers</li>
<li><span id="regalias-a0-through-a7"><em><code>a0</code> through
<code>a7</code></em></span> are <em>argument</em> registers</li>
<li><span id="regalias-zero"><em><code>zero</code></em></span> is the,
well, zero register</li>
<li><span id="regalias-ra"><em><code>ra</code></em></span> is for the
return address, by convention, as we’ve seen</li>
<li><span id="regalias-sp"><em><code>sp</code></em></span> … we’ll talk
about <code>sp</code> later</li>
<li>(The use of <span id="regalias-tp"><em><code>tp</code></em></span>
and <span id="regalias-gp"><em><code>gp</code></em></span> is out of the
scope of this document.)</li>
</ul>
<p>(Yeah it’s… all placed in a weird order. The reason is out of the
scope of this tutorial.)</p>
<p>When you call a function, you put up to eight arguments in the… well,
argument registers, in the order <code>a0</code>, <code>a1</code>, …,
<code>a7</code>. After that you use <code>jal</code> or something, which
puts the return address in <code>ra</code>, and jumps to the
function.</p>
<p>Inside, the function, if it wishes to use the <span
id="term-call-saved"><em>call-saved</em></span> registers
<code>s0</code> through <code>s11</code>, it must save their values at
the start of the function, and restore them before returning. The non
call-saved registers <code>a0</code> through <code>a7</code>,
<code>t0</code> through <code>t6</code> and <code>ra</code> may be
modified without restoring their values.</p>
<p>When the called function is done, it would, as mentioned, restore any
used call-saved registers, and jump back to the return address, resuming
the calling code.</p>
<p>Here’s a basic-ish example:</p>
<pre><code>int memcmp(const void *a, const void *b, size_t n)</code></pre>
<p>The parameter <code>a</code> is passed in <code>a0</code>,
<code>b</code> is passed in <code>a1</code>, and <code>n</code> is
passed in <code>a2</code>. The return value will be in <code>a0</code>.
Here’s an implementation and test run:</p>
<div class="emulator-disabled">
    # memcmp(test1, test2, 4)

    lui a0, %hi(test1)
    addi a0, a0, %lo(test1)
    lui a1, %hi(test2)
    addi a1, a1, %lo(test2)
    li a2, 4
    jal memcmp
    ebreak

    # int memcmp(const void *a, const void *b, size_t n);
memcmp:
    add a3, a0, a2 # a3 = a + n
    li t0, 0

memcmp_loop:
    beq a0, a3, memcmp_done # No more bytes

    lb t0, 0(a0)
    lb t1, 0(a1)
    sub t0, t0, t1  # t0 = *a - *b

    bne t0, zero, memcmp_done # If different, done

    addi a0, a0, 1  # a ++
    addi a1, a1, 1  # b ++

    j memcmp_loop

memcmp_done:
    mv a0, t0
    ret

test1:
    .byte 1, 2, 3, 4
test2:
    .byte 1, 2, 2, 4
</div>
<p>Here’s a slightly better-organized “Hello World”, using a
<code>puts</code> function:</p>
<div class="emulator-disabled">
    lui a0, %hi(msg)
    addi a0, a0, %lo(msg)
    jal puts
    ebreak

    # void puts(const char *);
puts:
    lui t1, %hi(0x10000000)
puts_loop:
    lb t0, 0(a0)
    beq t0, zero, puts_done
    sw t0, 0(t1)
    addi a0, a0, 1
    j puts_loop

puts_done:
    ret

msg:
    .byte 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x77
    .byte 0x6f, 0x72, 0x6c, 0x64, 0x21, 0x0a, 0x00
</div>
<h2 id="the-stack"><a href="#the-stack" class="anchor-link"
aria-hidden="true"></a>The stack</h2>
<p>Although we can write some very basic functions now, there are still
a few problems:</p>
<ul>
<li>You can’t call a function within another function because if you do
so <code>ra</code> would be overwritten, and then you can’t return back
from the outer function anymore.</li>
<li>We still don’t know how “saving” registers work.</li>
</ul>
<p>Clearly, both would require using memory somehow. We can feed two
birds with one scone by using memory in a structured way: The <span
id="term-stack"><em>stack</em></span>.</p>
<p>Unlike some other architectures, the <code>sp</code> register is not
really special in any way. But just like how we can designate how
<code>a0</code> is used, we can have some conventions about how
<code>sp</code> is supposed to be used:</p>
<ul>
<li>The register is call-saved, which means that when you return from a
function, <code>sp</code> needs to have the same value as when the
function was entered</li>
<li><code>sp</code> <em>always</em> points to somewhere in an area of
memory called the “stack”, and it is <em>always</em> 16-byte
aligned.</li>
</ul>
<p>And, for the stack itself:</p>
<ul>
<li>On RISC-V, the stack grows to lower addresses, meaning that the
memory where <code>address &gt;= sp</code> are “in the stack”, and
<code>address &lt; sp</code> are free space that the stack can grow
into.</li>
<li>Code can allocate space on the stack by decrementing
<code>sp</code>, and deallocate space by incrementing <code>sp</code>.
Of course, allocations and deallocations must be balanced properly.</li>
<li>You can only freely use space that you have allocated.</li>
</ul>
<p>An example is in order. Let’s say you have a function
<code>foo</code> which just calls <code>bar</code> twice.</p>
<pre><code>void foo() {
    bar();
    bar();
}</code></pre>
<p>Inside <code>foo</code>, it would need to save the initial
<code>ra</code>, so it can return back later. Even though
<code>ra</code> takes only 4 bytes, <code>sp</code> needs to be 16-byte
aligned at all times, so we round that up to 16 bytes. Decrementing
<code>sp</code> by 16 we allocate the space:</p>
<pre><code>foo:
    addi sp, sp, -16</code></pre>
<p>Now, in addition to all of the non call-saved registers, we have 16
bytes of scratch space at <code>sp</code> through <code>sp + 15</code>.
We can backup the value of <code>ra</code> here</p>
<pre><code>    ...
    sw ra, 0(sp)</code></pre>
<p>Then we just call <code>bar</code> twice, which overwrites
<code>ra</code>:</p>
<pre><code>    ...
    jal bar
    jal bar</code></pre>
<p>At the end of the function, we just need to get back the return
address, deallocate the stack space, and return. Although using any
register would suffice for the return address, since it is the backed up
value of <code>ra</code> after all, we load it back to
<code>ra</code>.</p>
<pre><code>    ...
    lw ra, 0(sp)
    addi sp, sp, 16
    ret</code></pre>
<p>In a similar way you can save and restore the <code>s</code>
(remember, call-saved) registers. Usually, the most convenient way to
manage this is to put values that need to be preserved across inner
function calls in the <code>s</code> registers, and then add code at the
beginning to save them, and add code at the end to restore them.</p>
<p>Obligatory recursive Fibonacci time!</p>
<div class="emulator-disabled">
    li a0, 10
    jal fib
    ebreak

fib:
    li t0, 2

    # If n &lt; 2, then return n
    bge a0, t0, fib_large
    ret

fib_large:
    # Otherwise, n &gt;= 2

    # Save stuff to stack
    addi sp, sp, -16
    sw ra, 0(sp)
    sw s0, 4(sp)
    sw s1, 8(sp)

    mv s0, a0       # s0 = n
    addi a0, a0, -1 # a0 = n - 1

    jal fib
    mv s1, a0       # s1 = fib(n - 1)

    addi a0, s0, -2
    jal fib         # fib(n - 2)

    add a0, a0, s1

    # Restore stuff from stack and return
    lw ra, 0(sp)
    lw s0, 4(sp)
    lw s1, 8(sp)
    addi sp, sp, 16
    ret
</div>
<p>The algorithm should be fairly straightforward:</p>
<pre><code>fibonacci(n) {
    if (n &lt; 2) { return n; }
    else { return fib(n - 1) + fib(n - 2); }
}</code></pre>
<p>What’s worth noting here is the fairly symmetric pattern of saving
registers at the start:</p>
<pre><code>    addi sp, sp, -16
    sw ra, 0(sp)
    sw s0, 4(sp)
    sw s1, 8(sp)</code></pre>
<p>And restoring them at the end:</p>
<pre><code>    lw ra, 0(sp)
    lw s0, 4(sp)
    lw s1, 8(sp)
    addi sp, sp, 16
    ret</code></pre>
<p>A little thing to also note that the <code>s</code> registers are
only saved in the more complex branch, where as the simpler branch just
returns directly. This is also acceptable from a calling convention
perspective.</p>
<p>(Note: In the emulator, the <code>sp</code> register is initialized
to an address that would be convenient for you for use as a stack, as a,
well, convenience.)</p>
<h1 id="intermission-numeric-labels"><a
href="#intermission-numeric-labels" class="anchor-link"
aria-hidden="true"></a>Intermission: Numeric labels</h1>
<p>Let’s go back to this example:</p>
<pre><code>    # void puts(const char *);
puts:
    lui t1, %hi(0x10000000)
puts_loop:
    lb t0, 0(a0)
    beq t0, zero, puts_done
    sw t0, 0(t1)
    addi a0, a0, 1
    j puts_loop

puts_done:
    ret</code></pre>
<p>Having to name things like <code>puts_loop</code>,
<code>puts_done</code> is a bit annoying. There’s a shorter way: <span
id="term-numeric-labels"><em>numeric labels</em></span>.</p>
<p>A numeric label is one with a name of a decimal number. To refer to a
numeric label, use the number and a <code>f</code> suffix for “forward”,
and <code>b</code> for “backward”, and it will correspond to the nearest
numeric label with that number, searching forwards or backwards,
respectively.</p>
<p>So, the <code>puts</code> example from earlier can be rewritten:</p>
<pre><code>    # void puts(const char *);
puts:
    lui t1, %hi(0x10000000)
1:
    lb t0, 0(a0)
    beq t0, zero, 2f
    sw t0, 0(t1)
    addi a0, a0, 1
    j 1b

2:
    ret</code></pre>
<p>Yeah I don’t really like this syntax either, but it is what we’ve
got.</p>
<h1 id="position-independence"><a href="#position-independence"
class="anchor-link" aria-hidden="true"></a>Position independence</h1>
<p>Remember that oddball instruction I mentioned way back,
<code>auipc</code>?</p>
<p>I don’t know about your experience, but the first time I saw RISC-V
disassembly, this is the one instruction that caught my eye. And this
memory has stuck with me ever since. It’s a rather common occurrence in
real RISC-V programs, and somehow I’ve been hiding it from you this
whole time. If you take a sneak peek at the next section’s title, you’ll
see how far we’ve come without <code>auipc</code>.</p>
<p>So what does it do?</p>
<p>The <span id="insn-auipc"><em><code>auipc</code></em></span> (“add
upper immediate to pc”) instruction is very similar to <code>lui</code>.
Instead of setting <code>rd</code> to <code>imm20 &lt;&lt; 12</code>, it
sets it to <code>pc + (imm20 &lt;&lt; 12)</code>, where <code>pc</code>
is the address of the <code>auipc</code> instruction itself.</p>
<pre><code>auipc rd, imm20</code></pre>
<p>It works very similarly to <code>lui</code>. You can think of them as
a pair: the “base” of <code>lui</code> is <code>0</code>, whereas the
“base” of <code>auipc</code> is the address of the <code>auipc</code>
instruction. So this code:</p>
<pre><code>start:
    lui a0, 3
    addi a0, a0, 4</code></pre>
<p>Gives you <code>0x3004</code>, whereas this:</p>
<pre><code>start:
    auipc a0, 3
    addi a0, a0, 4</code></pre>
<p>Gives you <code>start + 0x3004</code>.</p>
<p>Why would you need this? On modern systems, it’s often desirable to
have machine code that can be moved around in address space. For
example, a shared library i.e. dynamically linked library can be loaded
into any program, at any address. It would be helpful if the machine
code does not need to be patched every time. This is called <span
id="term-position-independent-code"><em>position independent
code</em></span> (<span id="term-pic"><em>PIC</em></span>).</p>
<p>Some instructions already exhibit position independence. For example,
as mentioned earlier when we talked about using <code>lui</code> and
<code>jalr</code> as a pair, the branch instructions and
<code>jal</code> are encoded, as with all RV32I instructions, into
32-bit instruction words, so they can’t possibly be able to encode every
possible address. Instead, the jump destination is <code>pc</code> plus
some offset (<code>pc</code> being, as before, the jump/branch
instruction itself), and the offset itself is encoded.</p>
<p>You can see these are three different instructions that jump to
itself. Since the offset is <code>0</code> in each case, the encoding is
the same. Use the “Dump” button to see for yourself.</p>
<div class="emulator-disabled">
    ebreak

test1:
    j test1

test2:
    j test2

test3:
    j test3
</div>
<p>The <code>auipc</code> instruction allows for very flexible position
independence. You can make arbitrary calculations based on the address
at which code is located. The immediate-bit operand mirroring
<code>lui</code> means that it is well suited for two-instruction pairs,
just like <code>lui</code>. These kind of “<code>pc</code> plus
something” calculations are known as <span
id="term-pc-relative-addressing"><em>pc-relative
addressing</em></span>.</p>
<p>The syntax for getting the assembler to generate the immediate values
for pc-relative addressing a bit arcane but hear me out:</p>
<div class="emulator-disabled">
1:
    auipc a0, %pcrel_hi(foo)
    addi a0, a0, %pcrel_lo(1b)
    ebreak

foo:
    .word 0x12345
</div>
<p>Like <code>%hi()</code> and <code>%lo()</code>, <span
id="rel-%pcrel_hi()"><em><code>%pcrel_hi()</code></em></span> and <span
id="rel-%pcrel_lo()"><em><code>%pcrel_lo()</code></em></span> gives you
the immediate values needed for pc-relative addressing. You pass the
label you want to address to <code>%pcrel_hi()</code>, but pass a label
to <em>the <code>auipc</code> instruction</em> to
<code>%pcrel_lo()</code>.</p>
<p>Unlike <code>%lo()</code>, We need the address of the
<code>auipc</code> instruction itself to calculate the immediate value,
and this is why you need to pass a label to it. You don’t need to write
<code>foo</code> again, since the assembler will look at the
<code>auipc</code> instruction and see it’s supposed to be for
<code>foo</code>.</p>
<p>If you hate writing that, you can also use the convenience
pseudoinstruction <span
id="insn-la"><em><code>la</code></em></span>:</p>
<pre><code>la rd, label</code></pre>
<p>Just like a <code>lui</code> + <code>jalr</code> pair, an
<code>auipc</code> + <code>jalr</code> can be used to jump to somewhere
farther away than one <code>jal</code> can reach in position-independent
code.</p>
<p>One very common case is to call a function that might not be within
reach of <code>jal</code>. You can use the pseudoinstruction <span
id="insn-call"><em><code>call</code></em></span> for that.</p>
<pre><code>call label</code></pre>
<p>This expands to:</p>
<pre><code>1:
    auipc ra, %pcrel_hi(label)
    jalr ra, %pcrel_lo(1b)(ra)</code></pre>
<p>Notice how <code>ra</code> is used as a temporary register to store
the intermediate result, which is immediately overwritten by
<code>jalr</code>.</p>
<p>In fact, there really isn’t any reason to prefer <code>lui</code>
over <code>auipc</code> when using a label. This is why you if you
disassemble a real RISC-V program, you see it everywhere, even in
non-position-independent code.</p>
<p>Now would be a good time to take a break, since we’re ready to head
into…</p>
<h1 id="privileged-architecture-fundamentals"><a
href="#privileged-architecture-fundamentals" class="anchor-link"
aria-hidden="true"></a>Privileged architecture fundamentals</h1>
<p>We’re going to write an <em>extremely</em> bare bones operating
system.</p>
<h2 id="privilege-levels"><a href="#privilege-levels"
class="anchor-link" aria-hidden="true"></a>Privilege levels</h2>
<p>One of the tasks an operating system performs is to control what
programs can and cannot do. On RISC-V, the most basic of this control is
implemented using <span id="term-privilege-levels"><em>privilege
levels</em></span>. RISC-V defines… let’s just say, several privilege
levels, but we’re only going to use two here:</p>
<ul>
<li>“<span id="term-machine"><em>Machine</em></span>”, number 3</li>
<li>“<span id="term-user"><em>User</em></span>”, number 0</li>
</ul>
<p>The lower the privilege level number goes, the less privileged that
level is. Higher privilege levels treat lower privilege levels as
generally completely unreliable and untrusted, and must isolate
themselves from adversarial software and failures of lower privilege
levels.</p>
<p>(However, we won’t be talking about all of the features that make
this full isolation possible, and the emulator you’ve been seeing does
not have enough features for that anyway. Therefore, the operating
system we’ll be building will leave itself unprotected in various
ways.)</p>
<p>The privilege levels are sometimes called “<span
id="term-modes"><em>modes</em></span>” for short. And, if that’s not
short enough, we can shorten the level names themselves, ending up with
<span id="term-m-mode"><em>M-mode</em></span> and <span
id="term-u-mode"><em>U-mode</em></span>. All of the ways to refer to
these privilege levels are interchangable.</p>
<p>When a RISC-V machine starts (This is known as “<span
id="term-reset"><em>reset</em></span>”), it begins execution in Machine
mode. On a typical “embedded” system where only Machine mode and User
mode are implemented, execution begins in the initialization code read
from flash memory. This code can either perform what needs to be done
itself, or it can be an operating system that manages some tasks, each
executing in User mode.</p>
<p>The former design is used for simpler programs, and is analogous to
the programs we’ve seen and run so far. The latter is more complicated.
We’ll see the basics of how to achieve that soon.</p>
<h2 id="control-and-status-registers-csrs"><a
href="#control-and-status-registers-csrs" class="anchor-link"
aria-hidden="true"></a>Control and status registers (CSRs)</h2>
<p>The <span id="term-control-and-status-registers"><em>control and
status registers</em></span> (<span id="term-csrs"><em>CSRs</em></span>)
deal with various features that are in some sense “special”. No I don’t
have a better explanation of what “special” means.</p>
<p>Six instructions are available for manipulating CSRs.</p>
<pre><code>csrrw rd, csr, rs1
csrrs rd, csr, rs1
csrrc rd, csr, rs1
csrrwi rd, csr, uimm5
csrrsi rd, csr, uimm5
csrrci rd, csr, uimm5</code></pre>
<p>To refer to a CSR in these instructions, use its name in assembly
code. We’ll get to those in a bit.</p>
<p>The pattern works like this. Each of the instructions
<em>atomically</em> reads the old value of the CSR, and writes the new
value based on some operation performed on the old value and the last
operand. The possible operations are:</p>
<ul>
<li><span id="insn-csrrw"><em><code>csrrw</code></em></span> (“CSR read
write”): <code>{ csr = rs1; rd = csr_old; }</code></li>
<li><span id="insn-csrrs"><em><code>csrrs</code></em></span> (“CSR read
set”): <code>{ csr = csr | rs1; rd = csr_old; }</code></li>
<li><span id="insn-csrrc"><em><code>csrrc</code></em></span> (“CSR read
clear”): <code>{ csr = csr &amp; ~rs1; rd = csr_old; }</code></li>
</ul>
<p>Where <code>&amp;</code>, <code>|</code>, <code>~</code> are bitwise
“and”, “or”, “not” respectively.</p>
<p>Specifically, note that <code>rd</code> and <code>rs1</code> can be
the same. For example, this instruction swaps the value in
<code>a0</code> and <code>mscratch</code>:</p>
<pre><code>csrrw a0, mscratch, a0</code></pre>
<p>For the “immediate” variants, instead of a register, they take an
“unsigned”/zero-extended 5-bit immediate value, i.e. an immediate value
0 through 31, inclusive. This is represented using <code>uimm5</code> in
the assembly syntax description. The operation is the same
otherwise.</p>
<ul>
<li><span id="insn-csrrwi"><em><code>csrrwi</code></em></span> (“CSR
read write immediate”): <code>{ csr = uimm5; rd = csr_old; }</code></li>
<li><span id="insn-csrrsi"><em><code>csrrsi</code></em></span> (“CSR
read set immediate”):
<code>{ csr = csr | uimm5; rd = csr_old; }</code></li>
<li><span id="insn-csrrci"><em><code>csrrci</code></em></span> (“CSR
read clear immediate”):
<code>{ csr = csr &amp; ~uimm5; rd = csr_old; }</code></li>
</ul>
<p>The full feature set of these instructions are designed for
manipulating bit fields in CSRs, which we will not be doing that much of
in this tutorial. Still, this orthogonal design should be fairly
intuitive to remember.</p>
<p>CSRs and fields in CSRs do not behave like general purpose registers:
Some of them are read/write, some are read-only. Also, invalid values
have special behaviors. We will touch on more details as we introduce
the individual CSRs themselves, but one thing you may have noticed is
that we don’t seem to have read-only CSR instructions. Read-only access
is achieved using special cases in the instruction encodings:</p>
<ul>
<li><code>csrrs</code> and <code>csrrc</code> do not write to the CSR if
<code>rs1</code> is <code>x0</code> (a.k.a. <code>zero</code>) (Note
that just the value of <code>rs1</code> being 0 is not enough.)</li>
<li><code>csrrsi</code> and <code>csrrci</code> do not write to the CSR
if <code>uimm5</code> is 0.</li>
</ul>
<p>While we’re at it:</p>
<ul>
<li><code>csrrw</code> and <code>csrrwi</code> do not read the CSR if
<code>rd</code> is <code>x0</code> (a.k.a. <code>zero</code>). (Note
that writing to <code>x0</code> has no effect anyway, since it’s
constant 0.)</li>
</ul>
<p>(No standard RISC-V CSR is write-only, or has side effects on
read.)</p>
<p>As a convenience, the pseudoinstructions <span
id="insn-csrr"><em><code>csrr</code></em></span> (“CSR read”) and <span
id="insn-csrw"><em><code>csrw</code></em></span> (“CSR write”) are
available. <code>csrw csr, rs1</code> expands to
<code>csrrw x0, csr, rs1</code>. Meanwhile, <code>csrr rd, csr</code>
expands specifically to <code>csrrs rd, csr, x0</code>, just so we can
agree on an encoding.</p>
<pre><code>csrw csr, rs1
csrr rd, csr</code></pre>
<p>You may have seen these CSR things if you’ve scrolled down on the
register view. Yes, we’re finally getting into those.</p>
<h2 id="counters"><a href="#counters" class="anchor-link"
aria-hidden="true"></a>Counters</h2>
<p>An example of CSRs is <span
id="term-counters"><em>counters</em></span>. Two basic read-only
counters are <span id="csr-cycle"><em><code>cycle</code></em></span> and
<span id="csr-instret"><em><code>instret</code></em></span>. These
counters, well, <em>count</em> the number of “cycles” and “instructions
retired”. “Retired” is a technical term basically meaning “successfully
completed”.</p>
<p>Since a 32-bit counter will overflow quite fast, on RV32, the
counters have “high” counterparts: <span
id="csr-cycleh"><em><code>cycleh</code></em></span> and <span
id="csr-instreth"><em><code>instreth</code></em></span>. So, for
example, the full cycle counter has 64 bits, with the lower 32 bits in
the CSR <code>cycle</code> and higher 32 bits in the CSR
<code>cycleh</code>.</p>
<p>While the emulator is running, scroll down on the register view
panel, and on the bottom you’ll see the values of these counters. For
convenience, they’re shown combined, so,
<code>cycle = 0x11223344_55667788</code> means <code>cycleh</code> is
<code>0x11223344</code>, and <code>cycle</code> is
<code>0x55667788</code>.</p>
<p>On real hardware <code>cycle</code> is coupled to the clock cycle. In
this emulator, every time you press “Step”, it counts as a cycle. When
you press “Run” and it starts, well, running, a certain number of cycles
happen periodically.</p>
<p>Let’s look at a really simple example:</p>
<div class="emulator-disabled">
    addi a0, a0, 1
    addi a0, a0, 1
    addi a0, a0, 1
    ebreak
</div>
<p>It takes 4 cycles for this program to stop, but <code>instret</code>
ends up at only 3 because the final <code>ebreak</code> instruction
never actually completes.</p>
<p>(Do not confuse “retired” with “retried”.)</p>
<p>A program can read its own counters. For example, this fun little
program loops until the cycle count is over 1000, assuming the low 32
bits doesn’t overflow before it has time to react:</p>
<div class="emulator-disabled">
    li t1, 1000
loop:
    csrr t0, cycle
    blt t0, t1, loop

    ebreak
</div>
<h2 id="current-privilege-level"><a href="#current-privilege-level"
class="anchor-link" aria-hidden="true"></a>Current privilege level</h2>
<p>Technically <code>cycle</code> and <code>instret</code> are not part
of the privileged architecture. The real fun begins <em>now</em>.</p>
<p>The emulator shows the current privilege level as
<code>(priv)</code>. It is in parentheses to remind you of a very
important fact:</p>
<p><em>There is no CSR for the current privilege level.</em></p>
<p>In general, it is not possible for a RISC-V program to learn what
privilege level it’s in. This is required for the <a
href="https://en.wikipedia.org/wiki/Popek_and_Goldberg_virtualization_requirements">Popek
and Goldberg conditions of virtualization</a> to work, specifically
because being able to read the current privilege level at a
lower-than-maximum privilege level would be a “sensitive” but
“unprivileged” instruction.</p>
<p>If you’re writing a program for a certain privilege level, you should
simply assume that it is correctly being run at that privilege
level.</p>
<h1 id="exceptions"><a href="#exceptions" class="anchor-link"
aria-hidden="true"></a>Exceptions</h1>
<h2 id="exception-entry"><a href="#exception-entry" class="anchor-link"
aria-hidden="true"></a>Exception entry</h2>
<p>A fundamental way an operating system does its job is through
handling exceptions. In general, <span
id="term-exceptions"><em>exceptions</em></span> occur when there’s a
problem with a specific instruction, and execution cannot continue. For
example, since <code>cycle</code> is a read-only CSR, writing to it is
an illegal instruction:</p>
<div class="emulator-disabled">
    csrw cycle, x0
</div>
<p>Since we have no exception handling in the program, we’ll have to
inspect what happened manually in the emulator. Indeed, a lot has
happened:</p>
<p>Firstly, this message tells you that an exception happened:</p>
<pre><code>[ Exception: Illegal instruction (2) | tval = 0xc0001073, epc = 0x4000000c ]</code></pre>
<p>The same information is now also available in the CSRs, as
follows:</p>
<ul>
<li><span id="csr-mcause"><em><code>mcause</code></em></span> (“M-mode
trap cause”): The kind of exception.</li>
<li><span id="csr-mepc"><em><code>mepc</code></em></span> (“M-mode
exception pc”): The address of the instruction that caused the
exception.</li>
<li><span id="csr-mtval"><em><code>mtval</code></em></span> (“M-mode
trap value”): Extra information about the exception.</li>
<li><span id="csr-mstatus"><em><code>mstatus</code></em></span> (“M-mode
status”): It is set to <code>0x00001800</code>. The two bits in the
middle, <code>mstatus[12:11]</code> (In C syntax,
<code>(mstatus &gt;&gt; 11) &amp; 0x3</code>) is the
<code>mstatus.MPP</code> (“M-mode previous privilege level”) field,
which contains 3, meaning that the exception occurred while running in
Machine mode.</li>
</ul>
<p>When an exception happens, in addition to recording the exception
information in these CSR fields, <code>pc</code> is set to
<code>mtvec</code>, which is supposed to be the handler address. Let’s
write ourselves an exception handler that simply prints a message and
stops the emulator, and see the handling in action:</p>
<div class="emulator-disabled">
    la t0, handler
    csrw mtvec, t0

    # Now cause an exception
    csrw cycle, x0

    # Rest of the main program is never executed
    addi a0, a0, 1
    addi a0, a0, 1

handler:
    la a0, msg
    call puts
    ebreak

msg:
    .byte 0x4f, 0x68, 0x20, 0x6e, 0x6f, 0x21, 0x0a, 0x00

    # void puts(const char *);
puts:
    lui t1, %hi(0x10000000)
1:
    lb t0, 0(a0)
    beq t0, zero, 2f
    sw t0, 0(t1)
    addi a0, a0, 1
    j 1b

2:
    ret
</div>
<p>Yeah it just prints <code>Oh no!</code> on error. Baby steps…</p>
<p>The checkboxes “Pause on exc.” and “Print on exc.” control whether
the emulator should pause or print a message, respectively, when an
exception occurs. You can uncheck those if you want the exception
handler set in the program to run without interference.</p>
<p>(Another case that will cause a jump to <code>mtvec</code> is <span
id="term-interrupts"><em>interrupts</em></span>. However, this feature
does not exist in the emulator. The two cases are collectively called
<span id="term-traps"><em>traps</em></span>.)</p>
<h2 id="exception-causes"><a href="#exception-causes"
class="anchor-link" aria-hidden="true"></a>Exception causes</h2>
<p>These are the exceptions possible in this emulator, and their
respective numeric codes:</p>
<table>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">0</td>
<td style="text-align: left;">Instruction address misaligned</td>
</tr>
<tr>
<td style="text-align: left;">1</td>
<td style="text-align: left;">Instruction access fault</td>
</tr>
<tr>
<td style="text-align: left;">2</td>
<td style="text-align: left;">Illegal instruction</td>
</tr>
<tr>
<td style="text-align: left;">3</td>
<td style="text-align: left;">Breakpoint</td>
</tr>
<tr>
<td style="text-align: left;">5</td>
<td style="text-align: left;">Load access fault</td>
</tr>
<tr>
<td style="text-align: left;">7</td>
<td style="text-align: left;">Store/AMO access fault</td>
</tr>
<tr>
<td style="text-align: left;">8</td>
<td style="text-align: left;">Environment call from User mode</td>
</tr>
<tr>
<td style="text-align: left;">11</td>
<td style="text-align: left;">Environment call from Machine mode</td>
</tr>
</tbody>
</table>
<p>“Instruction address misaligned” happens when attempting to jump to
an instruction that is not 4-byte aligned. The exception happens on the
jump or branch instruction, not the target.</p>
<p>“Load access fault” and “Store/AMO access fault” happens when
accessing an invalid memory address, or accessing a memory address in an
invalid way.</p>
<p>(“AMO” stands for “atomic memory operation”, which we will not talk
about and is not featured in the emulator.)</p>
<p>“Illegal instruction” happens not only in the self explanatory way
when an invalid instruction is executed, but also when accessing a CSR
in an invalid way, or from too low a privilege level.</p>
<p>“Breakpoint”, “Environment call from User mode” and “Environment call
from Machine mode” will be explained in a future section.</p>
<h2 id="exception-return"><a href="#exception-return"
class="anchor-link" aria-hidden="true"></a>Exception return</h2>
<p>The <span id="insn-mret"><em><code>mret</code></em></span> (“M-mode
return”) instruction performs the reverse of part of what happens when
an exception occurs. To be precise, what happens is:</p>
<ul>
<li>The current privilege levels is set back to
<code>mstatus.MPP</code></li>
<li><code>mstatus.MPP</code> is set to 0</li>
<li><code>pc</code> is set to <code>mepc</code></li>
</ul>
<p>(You can think of the privilege mode bits as shifting in a chain
<code>0 → MPP → priv</code>. And, to be even more precise,
<code>mstatus.MPP</code> is set to the lowest supported privilege mode
since it’s not supposed to contain unsupported modes.)</p>
<p><code>mret</code> takes no operands, so the assembly syntax is
simply:</p>
<pre><code>mret</code></pre>
<p>If we do <code>mret</code> after getting an exception, then we simply
go back to retrying the same instruction again. This is useful for more
featureful implementations, where for example, after handling a page
fault the correct course of action is to retry the faulting
instruction.</p>
<p>However, <code>mstatus</code> and <code>mepc</code> are also
writable. This gives us more flexibility in the use of
<code>mret</code>. As an analogy, the same <code>jr</code> instruction
(really <code>jalr</code> instruction) can be used to return from a
call, and also can be used to jump to any address. Similarly,
<code>mret</code> not only lets us return from an exception, but also
lets us jump to any address <em>and</em> switch to any privilege
level.</p>
<h1 id="handling-user-mode"><a href="#handling-user-mode"
class="anchor-link" aria-hidden="true"></a>Handling User mode</h1>
<h2 id="entering-user-mode"><a href="#entering-user-mode"
class="anchor-link" aria-hidden="true"></a>Entering User mode</h2>
<p>Even though <code>mret</code> is named “return”, it is in fact the
only way to lower the privilege level to <em>enter</em> User mode.
Here’s an example of entering User mode, with a User mode program that
does something bad:</p>
<div class="emulator-disabled">
    la t0, handler
    csrw mtvec, t0

    lui t0, %hi(0x1800)
    addi t0, t0, %lo(0x1800)

    # Clear MPP to 0
    csrrc zero, mstatus, t0

    la t0, user_entry
    csrw mepc, t0
    mret

handler:
    ebreak # Just stop the emulator

user_entry:
    # Try to access an M-mode CSR
    csrr a0, mstatus
</div>
<p>As you can see, after we enter User mode, all of the CSRs used for
exception handling become completely inaccessible, not even readable. As
with writing a read-only CSR, accessing an CSR without permission also
causes an illegal instruction exception.</p>
<p>Moreover, when an exception happens, we go back to Machine mode, so
the exception handler runs in Machine mode. Here the handler does
nothing except stopping the emulator.</p>
<h2 id="intentionally-causing-an-exception"><a
href="#intentionally-causing-an-exception" class="anchor-link"
aria-hidden="true"></a>Intentionally causing an exception</h2>
<p>Sometimes, a program may wish to intentionally cause an exception.
There are several well-defined way to do that:</p>
<ul>
<li>The pseudoinstruction <span
id="insn-unimp"><em><code>unimp</code></em></span> has the same encoding
as <code>csrrw zero, cycle, zero</code>, and it is the canonical RV32I
illegal instruction. It causes causes an “Illegal instruction”
exception.</li>
<li>The instruction <span
id="insn-ebreak"><em><code>ebreak</code></em></span> causes a
“Breakpoint” exception</li>
<li>The instruction <span
id="insn-ecall"><em><code>ecall</code></em></span> causes an
“Environment call from User mode” exception when executed in User mode,
and “Environment call from Machine mode” exception when executed in
Machine mode.</li>
</ul>
<p>Give those exceptions a try here:</p>
<div class="emulator-disabled">
    la t0, handler
    csrw mtvec, t0

    lui t0, %hi(0x1800)
    addi t0, t0, %lo(0x1800)

    # Clear MPP to 0
    csrrc zero, mstatus, t0

    la t0, user_entry
    csrw mepc, t0
    mret

handler:
    ebreak # Just stop the emulator

user_entry:
    ebreak
    # ecall
    # unimp
</div>
<p>As the names suggest, <code>ebreak</code> is used for debugging
breakpoints. As a special case, in this emulator <code>ebreak</code> in
Machine mode stops the emulator. You can think of it as the emulator
being a debugger, and the debugger catching the breakpoint.</p>
<p><code>unimp</code> can be used to intentionally crash a program upon
detection of some unrecoverable error.</p>
<p>Meanwhile, <code>ecall</code> is used for things like system calls.
“Environment call from User mode” is a distinct exception cause code to
make it easy to check specifically for this case.</p>
<h2 id="saving-and-restoring-all-registers"><a
href="#saving-and-restoring-all-registers" class="anchor-link"
aria-hidden="true"></a>Saving and restoring all registers</h2>
<p>One thing that you would want in your trap handler is to not trust or
disturb <em>any</em> general purpose registers in the code that the trap
occurred in, unless you intentionally want to do so, for example to
return a value from a system call. So you’d want to save all the
registers to memory, before doing anything else. However, accessing
memory requires a general purpose register.</p>
<p>The <span id="csr-mscratch"><em><code>mscratch</code></em></span>
(“M-mode scratch”) CSR can help with this. This register, unlike all the
others, have no special functionality. It can hold any 32-bit value.
However, like all the other M-mode CSRs, it can only be accessed in
Machine mode. User mode code cannot change the value of it.</p>
<p>So for example, you can stash the operating system stack pointer in
<code>mscratch</code> before switching to User mode, and it will stay in
<code>mscratch</code> untouched in User mode. At the top of the handler,
<code>csrrw sp, mscratch, sp</code> to swap from the user stack pointer
to the operating system stack pointer.</p>
<pre><code>handler:
    csrrw sp, mscratch, sp
    # Save registers except sp
    csrr t0, mscratch
    # t0 = user sp, save it
    # Save user pc
    ...</code></pre>
<p>And, to restore:</p>
<pre><code>    lw t0, ... # Load user pc
    csrw mepc, t0
    lw t0, ... # Load user sp
    csrw mscratch, t0
    # Restore registers except sp
    csrrw sp, mscratch, sp
    mret</code></pre>
<p>We’ll see the full code for this in the following section.</p>
<h1 id="writing-a-very-very-bare-bones-operating-system"><a
href="#writing-a-very-very-bare-bones-operating-system"
class="anchor-link" aria-hidden="true"></a>Writing a very very bare
bones operating system</h1>
<h2 id="design"><a href="#design" class="anchor-link"
aria-hidden="true"></a>Design</h2>
<p>We have enough to write a very very bare bones operating system. It
will support these features:</p>
<ul>
<li>System calls:
<ul>
<li><code>a7 = 1</code>: putchar, <code>a0</code> is the byte to
write</li>
<li><code>a7 = 2</code>: exit</li>
</ul></li>
<li>Exception handling: Print error message and exit</li>
</ul>
<p>We design the exception handling as follows:</p>
<ul>
<li>During most of the time in M-mode, <code>mscratch</code> is 0.</li>
<li>While in U-mode, <code>mscratch</code> points to the operating
system stack pointer</li>
<li>At trap handler, if <code>mscratch</code> is 0, the exception came
from M-mode, which we cannot handle, so we report a fatal
exception.</li>
<li>If it did come from U-mode, allocate 128 bytes on the stack to save
the U-mode registers, and call <code>trap_main</code>, which manipulates
U-mode registers in memory</li>
<li>After <code>trap_main</code>, we restore registers from memory,
deallocate the space from the stack, and go back to U-mode, as outlined
in the previous section.</li>
</ul>
<p>The structure to save registers in is fairly simple:</p>
<pre><code>struct regs {
  unsigned long pc;
  unsigned long ra; // x1
  unsigned long sp; // x2
  ...
  unsigned long t6; // x31
};</code></pre>
<p>Basically you can think of it as an array where element 0 is
<code>pc</code>, and elements 1 through 31 are registers x1 through
x31.</p>
<p>Inside <code>trap_main</code>, we check <code>mcause</code> to see if
it’s a system call. If it is, we dispatch based on <code>a7</code>. If
it’s not, we report an exception from U-mode.</p>
<p>At the beginning, we simply initialize the <code>struct regs</code>
structure on stack, initialize user <code>sp</code> and <code>pc</code>
in it, and jump to the same code that handles returning to U-mode.</p>
<h2 id="code"><a href="#code" class="anchor-link"
aria-hidden="true"></a>Code</h2>
<p>Here’s the assembly code with User mode code at the bottom. You may
want to uncheck “Pause on exc.” and “Print on exc.” for convenience.</p>
<p>Do not be too hard on yourself if you have trouble understanding the
code fully. This is, after all, a fairly complete OS kernel entry and
exit implementation. Really, the most important part I’m showing you
here is that it is possible.</p>
<div class="emulator-disabled">
    # Reserve 256 bytes for OS stack
    # User stack starts 256 bytes lower
    addi t2, sp, -256

    la t0, handler
    csrw mtvec, t0

    # Prepare struct reg
    addi sp, sp, -128

    mv a0, sp # struct regs *

    # Set user pc to user_entry
    la t0, user_entry
    sw t0, 0(a0)

    # Set user sp
    sw t2, 8(a0)

    j enter_user

    # void trap_main(struct regs *regs)
trap_main:
    # Save regs based on calling convention
    addi sp, sp, -16
    sw s0, (sp)
    sw ra, 4(sp)

    mv s0, a0
    csrr a1, mcause
    li t1, 8 # &quot;Environment call from User mode&quot;
    bne a1, t1, do_bad_exception # Not ecall, that's bad

    # Call do_syscall with args from ecall

    lw a0, 40(s0)
    lw a1, 44(s0)
    lw a2, 48(s0)
    lw a3, 52(s0)
    lw a4, 56(s0)
    lw a5, 60(s0)
    lw a6, 64(s0)
    lw a7, 68(s0)
    call do_syscall

    sw a0, 40(s0)   # Set user a0 return value

    # Bump user pc by 4
    # Skip over ecall instruction
    lw t0, 0(s0)
    addi t0, t0, 4
    sw t0, 0(s0)

    # Restore regs based on calling convention
    lw s0, (sp)
    lw ra, 4(sp)
    addi sp, sp, 16
    ret

    # a0 = arg0, a7 = syscall number
do_syscall:
    # Dispatch based on syscall number
    li t0, 1
    beq a7, t0, sys_putchar
    li t0, 2
    beq a7, t0, sys_exit

    # Bad syscall
    li a0, -1
    ret

    # int sys_putchar(char c)
sys_putchar:
    # Save regs based on calling convention
    addi sp, sp, -16
    sw s0, (sp)
    sw ra, 4(sp)

    call kputchar
    li a0, 0

    # Restore regs based on calling convention
    lw s0, (sp)
    lw ra, 4(sp)
    addi sp, sp, 16
    ret

    # [[noreturn]] void sys_exit()
sys_exit:
    # Just stop the emulator
    ebreak

    # [[noreturn]] void do_bad_exception(struct regs *regs, long cause)
    # Print message about bad U-mode exception, then stop
do_bad_exception:
    mv s0, a1

    # Equivalent of printf(&quot;Exception 0x%x&quot;, cause);
    la a0, msg_exception
    call kputs

    mv a0, s0
    la t0, hex_chars
    add t0, t0, a0
    lbu a0, (t0)
    call kputchar

    li a0, 0xa # '\n'
    call kputchar

    # Stop the emulator
    ebreak

fatal:
    # Print message about fatal exception, then stop
    la a0, msg_fatal
    call kputs
    ebreak

msg_exception:
    # &quot;Exception 0x&quot;
    .byte 0x45, 0x78, 0x63, 0x65, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x30, 0x78, 0x00

msg_fatal:
    # &quot;Fatal exception\n&quot;
    .byte 0x46, 0x61, 0x74, 0x61, 0x6c, 0x20, 0x65, 0x78, 0x63, 0x65, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x0a, 0x00

hex_chars:
    # &quot;0123456789abcdef&quot;
    .byte 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x00

    .byte 0x00 # Alignment padding
    # Otherwise, the next instruction wouldn't be aligned

    # void kputs(const char *);
    # Print string by accessing MMIO directly
kputs:
    lui t1, %hi(0x10000000)
1:
    lb t0, 0(a0)
    beq t0, zero, 2f
    sw t0, 0(t1)
    addi a0, a0, 1
    j 1b
2:
    ret

    # void kputchar(char);
    # Print byte by accessing MMIO directly
kputchar:
    lui t1, %hi(0x10000000)
    sw a0, (t1)
    ret

    # The big exception handler
handler:
    csrrw sp, mscratch, sp

    # If mscratch was 0, this is exception from M-mode
    # Can't handle that, it's a fatal error
    beq sp, zero, fatal

    # Save all registers
    addi sp, sp, -128
    sw x1, 4(sp)
    # x2/sp handled separately
    sw x3, 12(sp)
    sw x4, 16(sp)
    sw x5, 20(sp)
    sw x6, 24(sp)
    sw x7, 28(sp)
    sw x8, 32(sp)
    sw x9, 36(sp)
    sw x10, 40(sp)
    sw x11, 44(sp)
    sw x12, 48(sp)
    sw x13, 52(sp)
    sw x14, 56(sp)
    sw x15, 60(sp)
    sw x16, 64(sp)
    sw x17, 68(sp)
    sw x18, 72(sp)
    sw x19, 76(sp)
    sw x20, 80(sp)
    sw x21, 84(sp)
    sw x22, 88(sp)
    sw x23, 92(sp)
    sw x24, 96(sp)
    sw x25, 100(sp)
    sw x26, 104(sp)
    sw x27, 108(sp)
    sw x28, 112(sp)
    sw x29, 116(sp)
    sw x30, 120(sp)
    sw x31, 124(sp)

    # Save user sp, also set mscratch to 0 in M-mode
    csrrw t0, mscratch, zero
    sw t0, 8(sp)

    # Save user pc
    csrr t0, mepc
    sw t0, 0(sp)

    mv a0, sp
    call trap_main
    # ... falls through after trap_main ...
enter_user:
    # Set mstatus.MPP = User
    lui t0, %hi(0x1800)
    addi t0, t0, %lo(0x1800)
    csrrc zero, mstatus, t0

    # Set mepc = user pc
    # Will actually jump with mret
    lw t0, 0(sp)
    csrw mepc, t0

    # Set mscratch = user sp temporarily
    # Will swap right before mret
    lw t0, 8(sp)
    csrw mscratch, t0

    # Restore other registers from stack
    lw x1, 4(sp)
    # x2/sp handled separately
    lw x3, 12(sp)
    lw x4, 16(sp)
    lw x5, 20(sp)
    lw x6, 24(sp)
    lw x7, 28(sp)
    lw x8, 32(sp)
    lw x9, 36(sp)
    lw x10, 40(sp)
    lw x11, 44(sp)
    lw x12, 48(sp)
    lw x13, 52(sp)
    lw x14, 56(sp)
    lw x15, 60(sp)
    lw x16, 64(sp)
    lw x17, 68(sp)
    lw x18, 72(sp)
    lw x19, 76(sp)
    lw x20, 80(sp)
    lw x21, 84(sp)
    lw x22, 88(sp)
    lw x23, 92(sp)
    lw x24, 96(sp)
    lw x25, 100(sp)
    lw x26, 104(sp)
    lw x27, 108(sp)
    lw x28, 112(sp)
    lw x29, 116(sp)
    lw x30, 120(sp)
    lw x31, 124(sp)
    addi sp, sp, 128

    # Actually restore sp
    csrrw sp, mscratch, sp
    mret    # Time to go to user mode!

################

user_entry:
    la a0, msg_hello
    call puts
    call exit

    # void puts(const char *);
    # Print string using system call
puts:
    addi sp, sp, -16
    sw s0, (sp)
    sw ra, 4(sp)

    mv s0, a0
1:
    lb a0, 0(s0)
    beq a0, zero, 2f
    call putchar
    addi s0, s0, 1
    j 1b
2:

    lw s0, (sp)
    lw ra, 4(sp)
    addi sp, sp, 16
    ret

    # void putchar(const char *);
    # Print byte using system call
putchar:
    li a7, 1
    ecall
    ret

    # [[noreturn]] void exit();
exit:
    li a7, 2
    ecall
    # Not supposed to return, just to be safe
    unimp

msg_hello:
    .byte 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x21, 0x0a, 0x00
</div>
<h2 id="pseudocode-reference"><a href="#pseudocode-reference"
class="anchor-link" aria-hidden="true"></a>Pseudocode reference</h2>
<p>For reference, here’s some of the OS code in pseudo-C.</p>
<pre><code>void trap_main(struct regs *regs) {
    unsigned long cause = csr_read(mcause);
    if (cause != 8)
        do_bad_exception(regs, cause);

    # Call do_syscall with args from ecall
    unsigned long ret = do_syscall(regs-&gt;a0, ..., regs-&gt;a7);
    regs-&gt;a0 = ret;

    // Bump user pc by 4, skip over ecall instruction
    regs-&gt;pc += 4;
}

unsigned long do_syscall(
    unsigned long a0,
    ...,
    unsigned long a7
) {
    if (a7 == 1)
        sys_putchar(a0);
    else if (a7 == 8)
        sys_exit();
    else
        return -1;
}

unsigned long sys_putchar(char a) {
    kputchar(a);
    return 0;
}

[[noreturn]]
unsigned long sys_exit(char a) {
    ebreak();
}

[[noreturn]]
void do_bad_exception(struct regs *regs, unsigned long cause) {
    kputs(&quot;Exception 0x&quot;);
    kputchar(hex_chars[cause]);
    kputchar(&#39;\n&#39;);
    ebreak();
}

[[noreturn]]
void fatal() {
    kputs(&quot;Fatal exception\n&quot;);
    ebreak();
}

void kputs(const char *str) {
    while (*str) {
        u32 val = (u32)*str;
        writel(0x10000000, val); // MMIO write
        str ++;
    }
}

void kputchar(char c) {
    u32 val = (u32)c;
    writel(0x10000000, val); // MMIO write
}</code></pre>
<p>And here’s the user code, again in pseudo C:</p>
<pre><code>[[noreturn]]
void user_entry() {
    puts(...);
    exit();
}

void puts(const char *str) {
    while (*str) {
        putchar(*str);
        str ++;
    }
}

void putchar(char c) {
    ecall(a0 = c, a7 = 1);
}

void exit() {
    ecall(a7 = 2);
}</code></pre>
<h1 id="lies-and-omissions"><a href="#lies-and-omissions"
class="anchor-link" aria-hidden="true"></a>Lies and omissions</h1>
<p>As long as this tutorial is, some simplifications have been made.
Here are some of the most egregious lies and omissions, compared to the
“real” RISC-V architecture and “real” RISC-V assembly code found in the
world:</p>
<ul>
<li>The assembly syntax resembles the syntax used by LLVM assembler and
GNU Binutils for RISC-V. However, it is not identical.</li>
<li>There are a lot more pseudoinstructions and CSRs than what I have
described.</li>
<li>The <code>li</code> pseudoinstruction should support a wider range
of constants.</li>
<li><code>mstatus</code> is a lot more complicated than what I have
described.</li>
<li><code>%hi</code>, <code>%lo</code>, <code>%pcrel_hi</code>,
<code>%pcrel_lo</code> are more complicated than what I have
described.</li>
</ul>
<p>There are also very important topics that are common or even
ubiquitous in the RISC-V world, but I chose not to cover:</p>
<ul>
<li>64-bit architecture</li>
<li>Compressed instructions</li>
<li>Other privileged architecture and operating systems topics:
Interrupts, memory protection, virtual memory, …</li>
</ul>
<p>However, what I’ve taught you should be more than enough to get you
started into learning more on your own, or with further materials.</p>
<h1 id="references"><a href="#references" class="anchor-link"
aria-hidden="true"></a>References</h1>
<p>Here are some references and tutorials I would personally recommend,
if you’re looking to get further into RISC-V low-level development</p>
<ul>
<li>RISC-V Instruction Set Manual <a
href="https://github.com/riscv/riscv-isa-manual"
class="uri">https://github.com/riscv/riscv-isa-manual</a></li>
<li>RISC-V Assembly Programmer’s Manual <a
href="https://github.com/riscv-non-isa/riscv-asm-manual"
class="uri">https://github.com/riscv-non-isa/riscv-asm-manual</a></li>
<li>RISC-V Calling Conventions <a
href="https://github.com/riscv-non-isa/riscv-elf-psabi-doc/blob/master/riscv-cc.adoc"
class="uri">https://github.com/riscv-non-isa/riscv-elf-psabi-doc/blob/master/riscv-cc.adoc</a></li>
<li>Operating System in 1,000 Lines <a
href="https://operating-system-in-1000-lines.vercel.app/en/"
class="uri">https://operating-system-in-1000-lines.vercel.app/en/</a></li>
</ul>
<p>Other useful resources that I have used while writing this
tutorial:</p>
<ul>
<li><code>arch/riscv/kernel/entry.S</code> from Linux <a
href="https://elixir.bootlin.com/linux/latest/source/arch/riscv/kernel/entry.S"
class="uri">https://elixir.bootlin.com/linux/latest/source/arch/riscv/kernel/entry.S</a></li>
</ul>
<h1 id="thanks"><a href="#thanks" class="anchor-link"
aria-hidden="true"></a>Thanks</h1>
<p>Thanks to these folks for UI design help and content suggestions:</p>
<ul>
<li>Aria Desires <a href="https://faultlore.com"
class="uri">https://faultlore.com</a></li>
<li>Riven Skaye <a href="https://skaye.blog"
class="uri">https://skaye.blog</a></li>
<li>robotreader <a href="https://sdubinsky.com"
class="uri">https://sdubinsky.com</a></li>
<li>Bruce Hoult <a href="http://hoult.org/bruce"
class="uri">http://hoult.org/bruce</a></li>
<li>soxfox <a href="https://soxfox.me"
class="uri">https://soxfox.me</a></li>
<li>cbm-vic-20 on <a
href="https://news.ycombinator.com/item?id=45727405">Hacker
News</a></li>
<li>Clo91eaf <a href="https://clo91eaf.github.io"
class="uri">https://clo91eaf.github.io</a></li>
<li>Tom Hebb <a href="https://tchebb.me"
class="uri">https://tchebb.me</a></li>
</ul>
<p>And thanks to you for coming along with me on this journey. Come on
over to <a href="https://github.com/dramforever/easyriscv"
class="uri">https://github.com/dramforever/easyriscv</a> if you have
suggestions, grievances, or just want to share some thoughts.</p>
<h1 id="license"><a href="#license" class="anchor-link"
aria-hidden="true"></a>License</h1>
<p>This tutorial is provided under the <a
href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>
license. To the maximum extent permitted by law, this tutorial is
dedicated to the public domain.</p>
<p>The associated code in <a
href="https://github.com/dramforever/easyriscv">the repository</a> is
provided under, of your choosing, either the CC0 license or the <a
href="https://opensource.org/license/0bsd">0-clause “BSD”</a>
license.</p>
<h1 id="index"><a href="#index" class="anchor-link"
aria-hidden="true"></a>Index</h1>
<h2 id="instructions"><a href="#instructions" class="anchor-link"
aria-hidden="true"></a>Instructions</h2>
<ul>
<li><a href="#insn-add"><code>add</code></a></li>
<li><a href="#insn-addi"><code>addi</code></a></li>
<li><a href="#insn-and"><code>and</code></a></li>
<li><a href="#insn-andi"><code>andi</code></a></li>
<li><a href="#insn-auipc"><code>auipc</code></a></li>
<li><a href="#insn-beq"><code>beq</code></a></li>
<li><a href="#insn-bge"><code>bge</code></a></li>
<li><a href="#insn-bgeu"><code>bgeu</code></a></li>
<li><a href="#insn-blt"><code>blt</code></a></li>
<li><a href="#insn-bltu"><code>bltu</code></a></li>
<li><a href="#insn-bne"><code>bne</code></a></li>
<li><a href="#insn-call"><code>call</code></a></li>
<li><a href="#insn-csrr"><code>csrr</code></a></li>
<li><a href="#insn-csrrc"><code>csrrc</code></a></li>
<li><a href="#insn-csrrci"><code>csrrci</code></a></li>
<li><a href="#insn-csrrs"><code>csrrs</code></a></li>
<li><a href="#insn-csrrsi"><code>csrrsi</code></a></li>
<li><a href="#insn-csrrw"><code>csrrw</code></a></li>
<li><a href="#insn-csrrwi"><code>csrrwi</code></a></li>
<li><a href="#insn-csrw"><code>csrw</code></a></li>
<li><a href="#insn-ebreak"><code>ebreak</code></a></li>
<li><a href="#insn-ecall"><code>ecall</code></a></li>
<li><a href="#insn-j"><code>j</code></a></li>
<li><a href="#insn-jal"><code>jal</code></a></li>
<li><a href="#insn-jalr"><code>jalr</code></a></li>
<li><a href="#insn-jr"><code>jr</code></a></li>
<li><a href="#insn-la"><code>la</code></a></li>
<li><a href="#insn-lb"><code>lb</code></a></li>
<li><a href="#insn-lbu"><code>lbu</code></a></li>
<li><a href="#insn-lh"><code>lh</code></a></li>
<li><a href="#insn-lhu"><code>lhu</code></a></li>
<li><a href="#insn-li"><code>li</code></a></li>
<li><a href="#insn-lui"><code>lui</code></a></li>
<li><a href="#insn-lw"><code>lw</code></a></li>
<li><a href="#insn-mret"><code>mret</code></a></li>
<li><a href="#insn-mv"><code>mv</code></a></li>
<li><a href="#insn-or"><code>or</code></a></li>
<li><a href="#insn-ori"><code>ori</code></a></li>
<li><a href="#insn-ret"><code>ret</code></a></li>
<li><a href="#insn-sb"><code>sb</code></a></li>
<li><a href="#insn-sh"><code>sh</code></a></li>
<li><a href="#insn-sll"><code>sll</code></a></li>
<li><a href="#insn-slli"><code>slli</code></a></li>
<li><a href="#insn-slt"><code>slt</code></a></li>
<li><a href="#insn-slti"><code>slti</code></a></li>
<li><a href="#insn-sltiu"><code>sltiu</code></a></li>
<li><a href="#insn-sltu"><code>sltu</code></a></li>
<li><a href="#insn-sra"><code>sra</code></a></li>
<li><a href="#insn-srai"><code>srai</code></a></li>
<li><a href="#insn-srl"><code>srl</code></a></li>
<li><a href="#insn-srli"><code>srli</code></a></li>
<li><a href="#insn-sub"><code>sub</code></a></li>
<li><a href="#insn-sw"><code>sw</code></a></li>
<li><a href="#insn-unimp"><code>unimp</code></a></li>
<li><a href="#insn-xor"><code>xor</code></a></li>
<li><a href="#insn-xori"><code>xori</code></a></li>
</ul>
<h2 id="registers-and-csrs"><a href="#registers-and-csrs"
class="anchor-link" aria-hidden="true"></a>Registers and CSRs</h2>
<ul>
<li><a href="#reg-x0"><code>x0</code></a></li>
<li><a href="#reg-x1-through-x31"><code>x1</code> through
<code>x31</code></a></li>
</ul>
<ul>
<li><a href="#regalias-a0-through-a7"><code>a0</code> through
<code>a7</code></a></li>
<li><a href="#regalias-gp"><code>gp</code></a></li>
<li><a href="#regalias-ra"><code>ra</code></a></li>
<li><a href="#regalias-s0-through-s11"><code>s0</code> through
<code>s11</code></a></li>
<li><a href="#regalias-sp"><code>sp</code></a></li>
<li><a href="#regalias-t0-through-t6"><code>t0</code> through
<code>t6</code></a></li>
<li><a href="#regalias-tp"><code>tp</code></a></li>
<li><a href="#regalias-zero"><code>zero</code></a></li>
</ul>
<ul>
<li><a href="#csr-cycle"><code>cycle</code></a></li>
<li><a href="#csr-cycleh"><code>cycleh</code></a></li>
<li><a href="#csr-instret"><code>instret</code></a></li>
<li><a href="#csr-instreth"><code>instreth</code></a></li>
<li><a href="#csr-mcause"><code>mcause</code></a></li>
<li><a href="#csr-mepc"><code>mepc</code></a></li>
<li><a href="#csr-mscratch"><code>mscratch</code></a></li>
<li><a href="#csr-mstatus"><code>mstatus</code></a></li>
<li><a href="#csr-mtval"><code>mtval</code></a></li>
</ul>
<h2 id="special-assembly-syntax"><a href="#special-assembly-syntax"
class="anchor-link" aria-hidden="true"></a>Special assembly syntax</h2>
<ul>
<li><a href="#dir-.2byte"><code>.2byte</code></a></li>
<li><a href="#dir-.4byte"><code>.4byte</code></a></li>
<li><a href="#dir-.byte"><code>.byte</code></a></li>
<li><a href="#dir-.half"><code>.half</code></a></li>
<li><a href="#dir-.word"><code>.word</code></a></li>
</ul>
<ul>
<li><a href="#rel-%hi()"><code>%hi()</code></a></li>
<li><a href="#rel-%lo()"><code>%lo()</code></a></li>
<li><a href="#rel-%pcrel_hi()"><code>%pcrel_hi()</code></a></li>
<li><a href="#rel-%pcrel_lo()"><code>%pcrel_lo()</code></a></li>
</ul>
<h2 id="other-terms"><a href="#other-terms" class="anchor-link"
aria-hidden="true"></a>Other terms</h2>
<ul>
<li><a href="#term-align">align</a></li>
<li><a href="#term-aligned">aligned</a></li>
<li><a href="#term-branch">branch</a></li>
<li><a href="#term-byte">byte</a></li>
<li><a href="#term-call-saved">call-saved</a></li>
<li><a href="#term-control-and-status-registers">control and status
registers</a></li>
<li><a href="#term-counters">counters</a></li>
<li><a href="#term-csrs">CSRs</a></li>
<li><a href="#term-destination-register">destination register</a></li>
<li><a href="#term-devices">devices</a></li>
<li><a href="#term-directive">directive</a></li>
<li><a href="#term-endianness">endianness</a></li>
<li><a href="#term-exceptions">exceptions</a></li>
<li><a href="#term-extensions">extensions</a></li>
<li><a href="#term-general-purpose-registers">general purpose
registers</a></li>
<li><a href="#term-halfword">halfword</a></li>
<li><a href="#term-imm"><code>imm</code></a></li>
<li><a href="#term-immediate-value">immediate value</a></li>
<li><a href="#term-instruction-syntax">instruction syntax</a></li>
<li><a href="#term-interrupts">interrupts</a></li>
<li><a href="#term-jump">jump</a></li>
<li><a href="#term-load">load</a></li>
<li><a href="#term-m-mode">M-mode</a></li>
<li><a href="#term-machine">Machine</a></li>
<li><a href="#term-memory-mapped-i/o">memory mapped I/O</a></li>
<li><a href="#term-modes">modes</a></li>
<li><a href="#term-numeric-labels">numeric labels</a></li>
<li><a href="#term-pc"><code>pc</code></a></li>
<li><a href="#term-pc-relative-addressing">pc-relative
addressing</a></li>
<li><a href="#term-pic">PIC</a></li>
<li><a href="#term-position-independent-code">position independent
code</a></li>
<li><a href="#term-privilege-levels">privilege levels</a></li>
<li><a href="#term-program-counter">program counter</a></li>
<li><a href="#term-pseudoinstructions">pseudoinstructions</a></li>
<li><a href="#term-rd"><code>rd</code></a></li>
<li><a href="#term-register-aliases">register aliases</a></li>
<li><a href="#term-reset">reset</a></li>
<li><a href="#term-rs1"><code>rs1</code></a></li>
<li><a href="#term-rs2"><code>rs2</code></a></li>
<li><a href="#term-sign-extension">sign extension</a></li>
<li><a href="#term-source-register">source register</a></li>
<li><a href="#term-stack">stack</a></li>
<li><a href="#term-store">store</a></li>
<li><a href="#term-traps">traps</a></li>
<li><a href="#term-two’s-complement">two’s complement</a></li>
<li><a href="#term-u-mode">U-mode</a></li>
<li><a href="#term-user">User</a></li>
<li><a href="#term-word">word</a></li>
<li><a href="#term-zero-extension">zero extension</a></li>
</ul>
</body>
